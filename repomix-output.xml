This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-18T03:08:46.610Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
gradle/
  wrapper/
    gradle-wrapper.properties
  libs.versions.toml
src/
  main/
    kotlin/
      com/
        example/
          transit/
            api/
              TransitAPI.kt
            command/
              FareCommand.kt
              RouteCommand.kt
              StaffCommand.kt
              StationCommand.kt
              StatisticsCommand.kt
              TransitCommand.kt
            config/
              ConfigManager.kt
              Messages.kt
            conversation/
              GateSetupConversation.kt
            event/
              TransitEvents.kt
              TransitListener.kt
            fare/
              ZoneFareCalculator.kt
            listener/
              GateListener.kt
            manager/
              ConfigManager.kt
              DatabaseManager.kt
              FareManager.kt
              GateManager.kt
              RouteManager.kt
              StaffManager.kt
              StationManager.kt
              StatisticsManager.kt
              TransactionManager.kt
            model/
              FareRule.kt
              JourneyData.kt
              Models.kt
              StaffModels.kt
              TransactionType.kt
            statistics/
              StatisticsManager.kt
            util/
              Extensions.kt
            TransitPlugin.kt
    resources/
      config.yml
      plugin.yml
  test/
    kotlin/
      com/
        example/
          transit/
            TransitPluginTest.kt
.gitattributes
.gitignore
build.gradle.kts
gradle.properties
gradlew
gradlew.bat
README.md
settings.gradle.kts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="gradle/libs.versions.toml">
# This file was generated by the Gradle 'init' task.
# https://docs.gradle.org/current/userguide/platforms.html#sub::toml-dependencies-format
</file>

<file path="src/main/kotlin/com/example/transit/api/TransitAPI.kt">
package com.example.transit.api

import com.example.transit.TransitPlugin
import com.example.transit.model.*
import com.example.transit.statistics.StatisticsManager
import org.bukkit.Location
import org.bukkit.entity.Player
import java.util.UUID

class TransitAPI(private val plugin: TransitPlugin) {
    
    fun getSystemBalance(systemId: String): Double {
        return plugin.transactionManager.getSystemBalance(systemId)
    }

    fun isStaffMember(player: Player, systemId: String): Boolean {
        return plugin.staffManager.isStaff(player.uniqueId, systemId)
    }

    fun getStation(systemId: String, stationName: String): Station? {
        return plugin.stationManager.getStation("${systemId}_${stationName.toLowerCase()}")
    }

    fun getRoute(routeId: String): Route? {
        return plugin.routeManager.getRoute(routeId)
    }

    fun getPlayerTransactions(
        playerId: UUID,
        limit: Int = 10
    ): List<Transaction> {
        return plugin.transactionManager.getTransactionsByPlayer(playerId)
            .take(limit)
    }

    fun getSystemRevenue(
        systemId: String,
        period: StatisticsManager.StatisticsPeriod = StatisticsManager.StatisticsPeriod.ALL_TIME
    ): Double {
        return plugin.statisticsManager.getSystemStatistics(systemId, period)?.totalRevenue ?: 0.0
    }

    fun getStationStatistics(stationId: String): StatisticsManager.Statistics? {
        return plugin.statisticsManager.getStationStatistics(stationId)
    }

    fun getRouteStatistics(routeId: String): StatisticsManager.Statistics? {
        return plugin.statisticsManager.getRouteStatistics(routeId)
    }

    fun addStation(
        systemId: String,
        name: String,
        location: Location,
        zone: String = "1"
    ): Boolean {
        val station = Station(
            id = "${systemId}_${name.toLowerCase()}",
            name = name,
            systemId = systemId,
            location = location,
            zone = zone
        )
        return try {
            plugin.stationManager.addStation(station)
            true
        } catch (e: Exception) {
            false
        }
    }

    fun addRouteStation(routeId: String, stationId: String): Boolean {
        return plugin.routeManager.addStationToRoute(routeId, stationId)
    }

    fun removeStation(systemId: String, stationName: String): Boolean {
        val stationId = "${systemId}_${stationName.toLowerCase()}"
        return plugin.stationManager.removeStation(stationId)
    }

    fun updateStationStatus(stationId: String, status: StationStatus): Boolean {
        return plugin.stationManager.updateStationStatus(stationId, status)
    }

    fun getNearbyStations(location: Location, radius: Double): List<Station> {
        return plugin.stationManager.getNearbyStations(location, radius)
    }

    fun getActiveJourney(playerId: UUID): JourneyData? {
        return plugin.fareManager.getActiveJourney(playerId)
    }

    fun getSystemStaff(systemId: String): Set<StaffMember> {
        return plugin.staffManager.getSystemStaff(systemId)
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/command/FareCommand.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import org.bukkit.entity.Player

class FareCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    override fun onCommand(sender: CommandSender, command: Command, label: String, args: Array<out String>): Boolean {
        if (args.isEmpty()) {
            sender.sendMessage("§cUsage: /fare <system/refund> [uuid]")
            return true
        }

        when (args[0].toLowerCase()) {
            "refund" -> handleRefund(sender, args)
            else -> handleSystemBalance(sender, args[0])
        }
        return true
    }

    private fun handleRefund(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /fare refund <uuid>")
            return
        }

        if (plugin.fareManager.refundTransaction(args[1])) {
            sender.sendMessage("§aTransaction refunded successfully!")
        } else {
            sender.sendMessage("§cFailed to refund transaction!")
        }
    }

    private fun handleSystemBalance(sender: CommandSender, systemId: String) {
        val balance = plugin.transactionManager.getSystemBalance(systemId)
        sender.sendMessage("§6System Balance for $systemId: §f$${balance}")
    }

    override fun onTabComplete(sender: CommandSender, command: Command, label: String, args: Array<out String>): List<String> {
        if (args.isEmpty()) return emptyList()
        
        return when (args.size) {
            1 -> listOf("refund").filter { it.startsWith(args[0].toLowerCase()) }
            else -> emptyList()
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/command/RouteCommand.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import com.example.transit.model.Route
import net.md_5.bungee.api.chat.ClickEvent
import net.md_5.bungee.api.chat.ComponentBuilder
import net.md_5.bungee.api.chat.HoverEvent
import net.md_5.bungee.api.chat.TextComponent
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import org.bukkit.entity.Player

class RouteCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    
    private val reorderingSessions = mutableMapOf<Player, ReorderSession>()

    override fun onCommand(
        sender: CommandSender,
        command: Command,
        label: String,
        args: Array<out String>
    ): Boolean {
        if (sender !is Player) {
            sender.sendMessage("§cThis command can only be used by players!")
            return true
        }

        when {
            args.isEmpty() -> {
                sendHelp(sender)
                return true
            }
            args[0].equals("add", true) -> handleAddRoute(sender, args)
            args[0].equals("show", true) -> handleShowRoute(sender, args)
            args[0].equals("addstation", true) -> handleAddStation(sender, args)
            args[0].equals("reorder", true) -> handleReorder(sender, args)
            args[0].equals("select", true) -> handleSelect(sender, args)
            args[0].equals("remove", true) -> handleRemoveRoute(sender, args)
            else -> sendHelp(sender)
        }
        return true
    }

    private fun handleAddRoute(player: Player, args: Array<out String>) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to create routes!")
            return
        }

        if (args.size < 3) {
            player.sendMessage("§cUsage: /route add <system> <name>")
            return
        }

        val systemId = args[1]
        val routeName = args[2]

        // Check if system exists
        if (plugin.configManager.getTransitSystem(systemId) == null) {
            player.sendMessage("§cTransit system not found!")
            return
        }

        // Create route
        val route = Route(
            id = "${systemId}_${routeName.toLowerCase()}",
            name = routeName,
            systemId = systemId
        )

        if (plugin.routeManager.addRoute(route)) {
            player.sendMessage("§aRoute $routeName created successfully!")
        } else {
            player.sendMessage("§cFailed to create route! It may already exist.")
        }
    }

    private fun handleShowRoute(player: Player, args: Array<out String>) {
        if (args.size < 2) {
            player.sendMessage("§cUsage: /route show <route>")
            return
        }
        
        val route = plugin.routeManager.getRoute(args[1]) ?: run {
            player.sendMessage("§cRoute not found!")
            return
        }
        
        // Send route header
        player.sendMessage("§6Route: ${route.name}")
        player.sendMessage("§7System: ${route.systemId}")
        
        // Send interactive station list
        route.stations.forEachIndexed { index, stationId ->
            val station = plugin.stationManager.getStation(stationId)
            val component = TextComponent("§7${index + 1}. ${station?.name ?: stationId}")
            
            // Add teleport action
            component.clickEvent = ClickEvent(
                ClickEvent.Action.RUN_COMMAND,
                "/station tp ${route.systemId} ${station?.name}"
            )
            component.hoverEvent = HoverEvent(
                HoverEvent.Action.SHOW_TEXT, 
                ComponentBuilder("§eClick to teleport to this station").create()
            )
            
            player.spigot().sendMessage(component)
        }
    }

    private fun handleAddStation(player: Player, args: Array<out String>) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to modify routes!")
            return
        }

        if (args.size < 3) {
            player.sendMessage("§cUsage: /route addstation <route> <station>")
            return
        }

        val routeId = args[1]
        val stationId = args[2]

        // Check if route exists
        val route = plugin.routeManager.getRoute(routeId)
        if (route == null) {
            player.sendMessage("§cRoute not found!")
            return
        }

        // Check if station exists
        val station = plugin.stationManager.getStation(stationId)
        if (station == null) {
            player.sendMessage("§cStation not found!")
            return
        }

        // Add station to route
        if (plugin.routeManager.addStationToRoute(routeId, stationId)) {
            player.sendMessage("§aStation added to route successfully!")
        } else {
            player.sendMessage("§cFailed to add station! It may already be in the route.")
        }
    }

    private fun handleReorder(player: Player, args: Array<out String>) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to reorder routes!")
            return
        }

        if (args.size < 2) {
            player.sendMessage("§cUsage: /route reorder <route>")
            return
        }
        
        val route = plugin.routeManager.getRoute(args[1]) ?: run {
            player.sendMessage("§cRoute not found!")
            return
        }

        reorderingSessions[player] = ReorderSession(args[1], mutableListOf())
        player.sendMessage("""
            §aReordering route ${route.name}
            §7Click station signs in the desired order
            §7Use /route select to confirm the new order
            §7Use /route reorder cancel to cancel
        """.trimIndent())
    }

    private fun handleSelect(player: Player, args: Array<out String>) {
        val session = reorderingSessions[player] ?: run {
            player.sendMessage("§cNo active reordering session!")
            return
        }
        
        if (args.size > 1 && args[1].equals("cancel", true)) {
            reorderingSessions.remove(player)
            player.sendMessage("§cReordering cancelled!")
            return
        }
        
        val route = plugin.routeManager.getRoute(session.routeId) ?: return
        val newOrder = session.selectedIndices.map { route.stations[it] }
        
        if (plugin.routeManager.reorderStations(session.routeId, newOrder)) {
            player.sendMessage("§aRoute stations reordered successfully!")
        } else {
            player.sendMessage("§cFailed to reorder stations!")
        }
        
        reorderingSessions.remove(player)
    }

    private fun handleRemoveRoute(player: Player, args: Array<out String>) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to remove routes!")
            return
        }

        if (args.size < 2) {
            player.sendMessage("§cUsage: /route remove <route>")
            return
        }

        if (plugin.routeManager.removeRoute(args[1])) {
            player.sendMessage("§aRoute removed successfully!")
        } else {
            player.sendMessage("§cFailed to remove route!")
        }
    }

    private data class ReorderSession(
        val routeId: String,
        val selectedIndices: MutableList<Int>
    )

    private fun sendHelp(player: Player) {
        player.sendMessage("""
            §6Route Commands:
            §f/route add <system> <name> - Create a new route
            §f/route show <route> - Show route details
            §f/route addstation <route> <station> - Add station to route
            §f/route reorder <route> - Reorder stations in route
            §f/route remove <route> - Remove a route
        """.trimIndent())
    }

    override fun onTabComplete(
        sender: CommandSender,
        command: Command,
        alias: String,
        args: Array<out String>
    ): List<String> {
        if (sender !is Player) return emptyList()
        
        return when (args.size) {
            1 -> listOf("add", "show", "addstation", "reorder", "select", "remove")
                .filter { it.startsWith(args[0].toLowerCase()) }
            2 -> when (args[0].toLowerCase()) {
                "add" -> plugin.configManager.getSystems().map { it.id }
                "show", "reorder", "remove" -> plugin.routeManager.getRoutes()
                "addstation" -> plugin.routeManager.getRoutes()
                else -> emptyList()
            }.filter { it.startsWith(args[1].toLowerCase()) }
            3 -> when (args[0].toLowerCase()) {
                "addstation" -> plugin.stationManager.getSystemStations(args[1])
                    .map { it.id }
                    .filter { it.startsWith(args[2].toLowerCase()) }
                else -> emptyList()
            }
            else -> emptyList()
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/command/StaffCommand.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import com.example.transit.model.PaymentPeriod
import com.example.transit.model.StaffRole
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import org.bukkit.entity.Player
import java.util.UUID

class StaffCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    
    override fun onCommand(
        sender: CommandSender,
        command: Command,
        label: String,
        args: Array<out String>
    ): Boolean {
        if (args.isEmpty()) {
            sendHelp(sender)
            return true
        }

        when (args[0].toLowerCase()) {
            "list" -> handleList(sender, args)
            "add" -> handleAdd(sender, args)
            "remove" -> handleRemove(sender, args)
            "role" -> handleRole(sender, args)
            "shift" -> handleShift(sender, args)
            "performance" -> handlePerformance(sender, args)
            "salary" -> handleSalary(sender, args)
            else -> sendHelp(sender)
        }
        return true
    }

    private fun handleList(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.staff.list")) {
            sender.sendMessage("§cYou don't have permission to list staff members!")
            return
        }

        if (args.size < 2) {
            sender.sendMessage("§cUsage: /staff list <system>")
            return
        }

        val systemId = args[1]
        val staffList = plugin.staffManager.getSystemStaff(systemId)
        
        if (staffList.isEmpty()) {
            sender.sendMessage("§cNo staff members found for system $systemId")
            return
        }

        sender.sendMessage("§6Staff members for system $systemId:")
        staffList.forEach { staff ->
            val playerName = plugin.server.getOfflinePlayer(staff.playerId).name ?: staff.playerId
            sender.sendMessage("""
                §7- $playerName
                  §7Role: §f${staff.role}
                  §7Salary: §f$${staff.salary}
                  §7Payment Period: §f${staff.paymentPeriod}
            """.trimIndent())
        }
    }

    private fun handleAdd(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.staff.add")) {
            sender.sendMessage("§cYou don't have permission to add staff members!")
            return
        }

        if (args.size < 4) {
            sender.sendMessage("§cUsage: /staff add <system> <player> <salary> [role] [period]")
            return
        }

        val systemId = args[1]
        val player = plugin.server.getPlayer(args[2])
        if (player == null) {
            sender.sendMessage("§cPlayer not found!")
            return
        }

        val salary = args[3].toDoubleOrNull()
        if (salary == null || salary <= 0) {
            sender.sendMessage("§cInvalid salary amount!")
            return
        }

        val role = if (args.size > 4) {
            try {
                StaffRole.valueOf(args[4].uppercase())
            } catch (e: IllegalArgumentException) {
                StaffRole.TRAINEE
            }
        } else StaffRole.TRAINEE

        val period = if (args.size > 5) {
            try {
                PaymentPeriod.valueOf(args[5].uppercase())
            } catch (e: IllegalArgumentException) {
                PaymentPeriod.MONTHLY
            }
        } else PaymentPeriod.MONTHLY

        if (plugin.staffManager.addStaffMember(player.uniqueId, systemId, role, salary, period)) {
            sender.sendMessage("§aStaff member added successfully!")
            player.sendMessage("§aYou have been added as a staff member for system $systemId")
        } else {
            sender.sendMessage("§cFailed to add staff member! They may already be staff.")
        }
    }

    private fun handleRemove(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.staff.remove")) {
            sender.sendMessage("§cYou don't have permission to remove staff members!")
            return
        }

        if (args.size < 3) {
            sender.sendMessage("§cUsage: /staff remove <system> <player>")
            return
        }

        val systemId = args[1]
        val playerId = try {
            UUID.fromString(args[2])
        } catch (e: IllegalArgumentException) {
            plugin.server.getPlayer(args[2])?.uniqueId
        }

        if (playerId == null) {
            sender.sendMessage("§cPlayer not found!")
            return
        }

        if (plugin.staffManager.removeStaffMember(playerId, systemId)) {
            sender.sendMessage("§aStaff member removed successfully!")
            plugin.server.getPlayer(playerId)?.sendMessage(
                "§cYou have been removed from staff in system $systemId"
            )
        } else {
            sender.sendMessage("§cFailed to remove staff member!")
        }
    }

    private fun handleRole(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.staff.role")) {
            sender.sendMessage("§cYou don't have permission to modify staff roles!")
            return
        }

        if (args.size < 4) {
            sender.sendMessage("§cUsage: /staff role <system> <player> <role>")
            return
        }

        val systemId = args[1]
        val player = plugin.server.getPlayer(args[2])
        if (player == null) {
            sender.sendMessage("§cPlayer not found!")
            return
        }

        val role = try {
            StaffRole.valueOf(args[3].uppercase())
        } catch (e: IllegalArgumentException) {
            sender.sendMessage("§cInvalid role! Valid roles: ${StaffRole.values().joinToString()}")
            return
        }

        if (plugin.staffManager.updateStaffRole(player.uniqueId, systemId, role)) {
            sender.sendMessage("§aStaff role updated successfully!")
            player.sendMessage("§aYour role has been updated to $role in system $systemId")
        } else {
            sender.sendMessage("§cFailed to update staff role!")
        }
    }

    private fun handleShift(sender: CommandSender, args: Array<out String>) {
        if (sender !is Player) {
            sender.sendMessage("§cThis command can only be used by players!")
            return
        }

        if (args.size < 3) {
            sender.sendMessage("§cUsage: /staff shift <start/end> <system>")
            return
        }

        val systemId = args[2]
        when (args[1].toLowerCase()) {
            "start" -> {
                if (plugin.staffManager.startShift(sender.uniqueId, systemId)) {
                    sender.sendMessage("§aShift started successfully!")
                } else {
                    sender.sendMessage("§cFailed to start shift! You may already have an active shift.")
                }
            }
            "end" -> {
                if (plugin.staffManager.endShift(sender.uniqueId)) {
                    sender.sendMessage("§aShift ended successfully!")
                } else {
                    sender.sendMessage("§cFailed to end shift! No active shift found.")
                }
            }
            else -> sender.sendMessage("§cUsage: /staff shift <start/end> <system>")
        }
    }

    private fun handlePerformance(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.staff.performance")) {
            sender.sendMessage("§cYou don't have permission to view performance!")
            return
        }

        if (args.size < 2) {
            sender.sendMessage("§cUsage: /staff performance <player>")
            return
        }

        val player = plugin.server.getPlayer(args[1])
        if (player == null) {
            sender.sendMessage("§cPlayer not found!")
            return
        }

        val performance = plugin.staffManager.getStaffPerformance(player.uniqueId)
        if (performance == null) {
            sender.sendMessage("§cNo performance data found for this player!")
            return
        }

        sender.sendMessage("""
            §6Performance Report for ${player.name}:
            §7Transactions: §f${performance.transactions}
            §7Customer Interactions: §f${performance.customerInteractions}
            §7Incident Count: §f${performance.incidentCount}
            §7Last Evaluation: §f${performance.lastEvaluation}
        """.trimIndent())
    }

    private fun handleSalary(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.staff.salary")) {
            sender.sendMessage("§cYou don't have permission to modify salaries!")
            return
        }

        if (args.size < 4) {
            sender.sendMessage("§cUsage: /staff salary <system> <player> <amount>")
            return
        }

        val systemId = args[1]
        val player = plugin.server.getPlayer(args[2])
        if (player == null) {
            sender.sendMessage("§cPlayer not found!")
            return
        }

        val salary = args[3].toDoubleOrNull()
        if (salary == null || salary <= 0) {
            sender.sendMessage("§cInvalid salary amount!")
            return
        }

        if (plugin.staffManager.updateSalary(player.uniqueId, systemId, salary)) {
            sender.sendMessage("§aSalary updated successfully!")
            player.sendMessage("§aYour salary has been updated to $$salary")
        } else {
            sender.sendMessage("§cFailed to update salary!")
        }
    }

    override fun onTabComplete(
        sender: CommandSender,
        command: Command,
        alias: String,
        args: Array<out String>
    ): List<String> {
        return when (args.size) {
            1 -> listOf("list", "add", "remove", "role", "shift", "performance", "salary")
                .filter { it.startsWith(args[0].toLowerCase()) }
            2 -> when (args[0].toLowerCase()) {
                "list", "add", "remove", "role", "salary" -> 
                    plugin.configManager.getSystems().map { it.id }
                "shift" -> listOf("start", "end")
                "performance" -> plugin.server.onlinePlayers.map { it.name }
                else -> emptyList()
            }.filter { it.startsWith(args[1].toLowerCase()) }
            3 -> when (args[0].toLowerCase()) {
                "add", "remove", "role", "salary" -> 
                    plugin.server.onlinePlayers.map { it.name }
                "shift" -> plugin.configManager.getSystems().map { it.id }
                else -> emptyList()
            }.filter { it.startsWith(args[2].toLowerCase()) }
            4 -> when (args[0].toLowerCase()) {
                "role" -> StaffRole.values().map { it.name.toLowerCase() }
                else -> emptyList()
            }.filter { it.startsWith(args[3].toLowerCase()) }
            else -> emptyList()
        }
    }

    private fun sendHelp(sender: CommandSender) {
        sender.sendMessage("""
            §6Staff Management Commands:
            §f/staff list <system> - List all staff members
            §f/staff add <system> <player> <salary> [role] [period] - Add staff member
            §f/staff remove <system> <player> - Remove staff member
            §f/staff role <system> <player> <role> - Change staff role
            §f/staff shift <start/end> <system> - Manage shifts
            §f/staff performance <player> - View performance stats
            §f/staff salary <system> <player> <amount> - Update salary
        """.trimIndent())
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/command/StationCommand.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import com.example.transit.model.Station
import com.example.transit.model.StationStatus
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import org.bukkit.entity.Player

class StationCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    
    override fun onCommand(
        sender: CommandSender,
        command: Command,
        label: String,
        args: Array<out String>
    ): Boolean {
        if (sender !is Player) {
            sender.sendMessage("§cThis command can only be used by players!")
            return true
        }

        when {
            args.isEmpty() -> {
                sendHelp(sender)
                return true
            }
            args[0].equals("add", true) -> handleAddStation(sender, args)
            args[0].equals("remove", true) -> handleRemoveStation(sender, args)
            args[0].equals("enable", true) -> handleStationStatus(sender, args, StationStatus.ACTIVE)
            args[0].equals("disable", true) -> handleStationStatus(sender, args, StationStatus.DISABLED)
            args[0].equals("maintenance", true) -> handleStationStatus(sender, args, StationStatus.MAINTENANCE)
            args[0].equals("tp", true) -> handleTeleport(sender, args)
            args[0].equals("list", true) -> handleList(sender, args)
            else -> sendHelp(sender)
        }
        return true
    }

    private fun handleAddStation(player: Player, args: Array<out String>) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to create stations!")
            return
        }

        if (args.size < 3) {
            player.sendMessage("§cUsage: /station add <system> <name> [zone]")
            return
        }

        val systemId = args[1]
        val stationName = args[2]
        val zone = if (args.size > 3) args[3] else "1"

        // Check if system exists
        if (plugin.configManager.getTransitSystem(systemId) == null) {
            player.sendMessage("§cTransit system not found!")
            return
        }

        // Create station
        val station = Station(
            id = "${systemId}_${stationName.toLowerCase()}",
            name = stationName,
            systemId = systemId,
            location = player.location,
            zone = zone
        )

        if (plugin.stationManager.addStation(station)) {
            player.sendMessage("§aStation $stationName created successfully!")
        } else {
            player.sendMessage("§cFailed to create station! It may already exist.")
        }
    }

    private fun handleRemoveStation(player: Player, args: Array<out String>) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to remove stations!")
            return
        }

        if (args.size < 3) {
            player.sendMessage("§cUsage: /station remove <system> <name>")
            return
        }

        val systemId = args[1]
        val stationName = args[2]
        val stationId = "${systemId}_${stationName.toLowerCase()}"

        if (plugin.stationManager.removeStation(stationId)) {
            player.sendMessage("§aStation $stationName removed from system $systemId")
        } else {
            player.sendMessage("§cStation not found!")
        }
    }

    private fun handleStationStatus(player: Player, args: Array<out String>, newStatus: StationStatus) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to modify stations!")
            return
        }

        if (args.size < 3) {
            player.sendMessage("§cUsage: /station ${args[0].toLowerCase()} <system> <name>")
            return
        }

        val systemId = args[1]
        val stationName = args[2]
        val stationId = "${systemId}_${stationName.toLowerCase()}"

        if (plugin.stationManager.updateStationStatus(stationId, newStatus)) {
            val statusText = when (newStatus) {
                StationStatus.ACTIVE -> "enabled"
                StationStatus.DISABLED -> "disabled"
                StationStatus.MAINTENANCE -> "put in maintenance"
            }
            player.sendMessage("§aStation $stationName has been $statusText!")
        } else {
            player.sendMessage("§cStation not found!")
        }
    }

    private fun handleTeleport(player: Player, args: Array<out String>) {
        if (!player.hasPermission("transit.tp")) {
            player.sendMessage("§cYou don't have permission to teleport to stations!")
            return
        }

        if (args.size < 3) {
            player.sendMessage("§cUsage: /station tp <system> <name>")
            return
        }

        val systemId = args[1]
        val stationName = args[2]
        val stationId = "${systemId}_${stationName.toLowerCase()}"

        val station = plugin.stationManager.getStation(stationId)
        if (station != null) {
            player.teleport(station.location)
            player.sendMessage("§aTeleported to station ${station.name}")
        } else {
            player.sendMessage("§cStation not found!")
        }
    }

private fun handleList(player: Player, args: Array<out String>) {
        if (args.size < 2) {
            player.sendMessage("§cUsage: /station list <system>")
            return
        }

        val systemId = args[1]
        val stations = plugin.stationManager.getSystemStations(systemId)
        
        if (stations.isEmpty()) {
            player.sendMessage("§cNo stations found for system $systemId")
            return
        }

        player.sendMessage("§6Stations in system $systemId:")
        stations.forEach { station ->
            val statusColor = when (station.status) {
                StationStatus.ACTIVE -> "§a"
                StationStatus.DISABLED -> "§c"
                StationStatus.MAINTENANCE -> "§e"
            }
            player.sendMessage("§7- ${station.name} (Zone: ${station.zone}) $statusColor${station.status}")
        }
    }

    private fun sendHelp(player: Player) {
        player.sendMessage("""
            §6Station Commands:
            §f/station add <system> <name> [zone] - Create a new station
            §f/station remove <system> <name> - Remove a station
            §f/station enable <system> <name> - Enable a station
            §f/station disable <system> <name> - Disable a station
            §f/station maintenance <system> <name> - Set station to maintenance
            §f/station tp <system> <name> - Teleport to a station
            §f/station list <system> - List all stations in a system
        """.trimIndent())
    }

    override fun onTabComplete(
        sender: CommandSender,
        command: Command,
        alias: String,
        args: Array<out String>
    ): List<String> {
        return when {
            args.isEmpty() -> listOf("add", "remove", "enable", "disable", "maintenance", "tp", "list")
            args.size == 1 -> listOf("add", "remove", "enable", "disable", "maintenance", "tp", "list")
                .filter { it.startsWith(args[0].toLowerCase()) }
            args.size == 2 -> plugin.configManager.getSystems()
                .map { it.id }
                .filter { it.startsWith(args[1].toLowerCase()) }
            args.size == 3 -> when (args[0].toLowerCase()) {
                "tp", "enable", "disable", "maintenance", "remove" -> plugin.stationManager
                    .getSystemStations(args[1])
                    .map { it.name }
                    .filter { it.startsWith(args[2].toLowerCase()) }
                else -> emptyList()
            }
            else -> emptyList()
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/command/StatisticsCommand.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import com.example.transit.statistics.StatisticsManager.StatisticsPeriod
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException

class StatisticsCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    
    private val dateFormat = DateTimeFormatter.ofPattern("yyyy-MM-dd")

    override fun onCommand(
        sender: CommandSender,
        command: Command,
        label: String,
        args: Array<out String>
    ): Boolean {
        if (!sender.hasPermission("transit.stats")) {
            sender.sendMessage("§cYou don't have permission to view statistics!")
            return true
        }

        if (args.isEmpty()) {
            sendHelp(sender)
            return true
        }

        when (args[0].toLowerCase()) {
            "system" -> handleSystemStats(sender, args)
            "station" -> handleStationStats(sender, args)
            "route" -> handleRouteStats(sender, args)
            "report" -> handleReport(sender, args)
            "peaks" -> handlePeakTimes(sender, args)
            "export" -> handleExport(sender, args)
            else -> sendHelp(sender)
        }
        return true
    }

    private fun handleSystemStats(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /stats system <systemId> [period]")
            return
        }

        val systemId = args[1]
        val period = if (args.size > 2) {
            try {
                StatisticsPeriod.valueOf(args[2].uppercase())
            } catch (e: IllegalArgumentException) {
                StatisticsPeriod.ALL_TIME
            }
        } else StatisticsPeriod.ALL_TIME

        val stats = plugin.statisticsManager.getSystemStatistics(systemId, period)
        if (stats == null) {
            sender.sendMessage("§cNo statistics found for system $systemId")
            return
        }

        sender.sendMessage("""
            §6System Statistics - $systemId ($period)
            §7Revenue: §f$${stats.totalRevenue}
            §7Transactions: §f${stats.totalTransactions}
            §7Average Fare: §f$${stats.averageFare}
            §7Entry Count: §f${stats.entryCount}
            §7Exit Count: §f${stats.exitCount}
            §7Direct Fares: §f${stats.directFares}
            §7Last Updated: §f${stats.lastUpdated}
            
            §6Hourly Breakdown:
            ${formatHourlyStats(stats.hourlyStats)}
        """.trimIndent())
    }

    private fun handleStationStats(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /stats station <stationId> [period]")
            return
        }

        val stationId = args[1]
        val period = if (args.size > 2) {
            try {
                StatisticsPeriod.valueOf(args[2].uppercase())
            } catch (e: IllegalArgumentException) {
                StatisticsPeriod.ALL_TIME
            }
        } else StatisticsPeriod.ALL_TIME

        val stats = plugin.statisticsManager.getStationStatistics(stationId, period)
        if (stats == null) {
            sender.sendMessage("§cNo statistics found for station $stationId")
            return
        }

        val station = plugin.stationManager.getStation(stationId)
        sender.sendMessage("""
            §6Station Statistics - ${station?.name ?: stationId} ($period)
            §7Revenue: §f$${stats.totalRevenue}
            §7Transactions: §f${stats.totalTransactions}
            §7Average Fare: §f$${stats.averageFare}
            §7Entry Count: §f${stats.entryCount}
            §7Exit Count: §f${stats.exitCount}
            §7Last Updated: §f${stats.lastUpdated}
            
            §6Hourly Usage:
            ${formatHourlyStats(stats.hourlyStats)}
        """.trimIndent())
    }

    private fun handleRouteStats(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /stats route <routeId> [period]")
            return
        }

        val routeId = args[1]
        val period = if (args.size > 2) {
            try {
                StatisticsPeriod.valueOf(args[2].uppercase())
            } catch (e: IllegalArgumentException) {
                StatisticsPeriod.ALL_TIME
            }
        } else StatisticsPeriod.ALL_TIME

        val stats = plugin.statisticsManager.getRouteStatistics(routeId, period)
        if (stats == null) {
            sender.sendMessage("§cNo statistics found for route $routeId")
            return
        }

        val route = plugin.routeManager.getRoute(routeId)
        sender.sendMessage("""
            §6Route Statistics - ${route?.name ?: routeId} ($period)
            §7Revenue: §f$${stats.totalRevenue}
            §7Transactions: §f${stats.totalTransactions}
            §7Average Fare: §f$${stats.averageFare}
            §7Last Updated: §f${stats.lastUpdated}
            
            §6Hourly Usage:
            ${formatHourlyStats(stats.hourlyStats)}
        """.trimIndent())
    }

    private fun handleReport(sender: CommandSender, args: Array<out String>) {
        if (args.size < 4) {
            sender.sendMessage("§cUsage: /stats report <systemId> <startDate> <endDate>")
            sender.sendMessage("§cDate format: YYYY-MM-DD")
            return
        }

        val systemId = args[1]
        val startDate = try {
            LocalDate.parse(args[2], dateFormat)
        } catch (e: DateTimeParseException) {
            sender.sendMessage("§cInvalid start date format. Use YYYY-MM-DD")
            return
        }

        val endDate = try {
            LocalDate.parse(args[3], dateFormat)
        } catch (e: DateTimeParseException) {
            sender.sendMessage("§cInvalid end date format. Use YYYY-MM-DD")
            return
        }

        val report = plugin.statisticsManager.generateReport(systemId, startDate, endDate)
        
        sender.sendMessage("""
            §6System Report - $systemId
            §7Period: §f${report.period.startDate} to ${report.period.endDate}
            
            §6Overall Statistics:
            §7Total Revenue: §f$${report.totalRevenue}
            §7Total Transactions: §f${report.totalTransactions}
            §7Average Transaction: §f$${report.averageTransactionValue}
            
            §6Peak Hours:
            ${formatPeakHours(report.peakHours)}
            
            §6Busiest Stations:
            ${formatBusyStations(report.busyStations)}
            
            §6Popular Routes:
            ${formatPopularRoutes(report.popularRoutes)}
        """.trimIndent())
    }

    private fun handlePeakTimes(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /stats peaks <systemId>")
            return
        }

        val systemId = args[1]
        val peakHours = plugin.statisticsManager.getPeakHours(systemId)
        
        if (peakHours.isEmpty()) {
            sender.sendMessage("§cNo peak time data available for system $systemId")
            return
        }

        sender.sendMessage("§6Peak Hours for $systemId:")
        peakHours.asIterable().forEach { peak ->
            sender.sendMessage("§7${peak.hour}:00 - ${peak.hour + 1}:00: §f${peak.transactions} transactions")
        }
    }

    private fun handleExport(sender: CommandSender, args: Array<out String>) {
        if (args.size < 3) {
            sender.sendMessage("§cUsage: /stats export <systemId> <type>")
            sender.sendMessage("§cTypes: csv, json")
            return
        }

        sender.sendMessage("§cExport functionality not yet implemented")
    }

    private fun formatHourlyStats(stats: Map<Int, Int>): String {
        return stats.entries
            .sortedBy { it.key }
            .joinToString("\n") { (hour, count) ->
                "§7${hour}:00 - ${hour + 1}:00: §f$count"
            }
    }

    private fun formatPeakHours(peakHours: List<StatisticsManager.PeakHour>): String {
        return peakHours.joinToString("\n") { peak -> 
            "§7${peak.hour}:00 - ${peak.hour + 1}:00: §f${peak.transactions} transactions"
        }
    }

    private fun formatBusyStations(stations: List<StatisticsManager.BusyStation>): String {
        return stations.take(5).joinToString("\n") { station ->
            "§7${station.name}: §f${station.usageCount} uses"
        }
    }

    private fun formatPopularRoutes(routes: List<StatisticsManager.PopularRoute>): String {
        return routes.take(5).joinToString("\n") { route ->
            val fromStation = plugin.stationManager.getStation(route.fromStationId)?.name ?: route.fromStationId
            val toStation = plugin.stationManager.getStation(route.toStationId)?.name ?: route.toStationId
            "§7$fromStation → $toStation: §f${route.usageCount} trips (avg: $${route.averageFare})"
        }
    }

    override fun onTabComplete(
        sender: CommandSender,
        command: Command,
        alias: String,
        args: Array<out String>
    ): List<String> {
        return when (args.size) {
            1 -> listOf("system", "station", "route", "report", "peaks", "export")
                .filter { it.startsWith(args[0].toLowerCase()) }
            2 -> when (args[0].toLowerCase()) {
                "system", "report", "peaks" -> plugin.configManager.getSystems().map { it.id }
                "station" -> plugin.stationManager.getAllStations().map { it.id }
                "route" -> plugin.routeManager.getRoutes()
                "export" -> plugin.configManager.getSystems().map { it.id }
                else -> emptyList()
            }.filter { it.startsWith(args[1].toLowerCase()) }
            3 -> when (args[0].toLowerCase()) {
                "system", "station", "route" -> 
                    StatisticsPeriod.values().map { it.name.toLowerCase() }
                "export" -> listOf("csv", "json")
                else -> emptyList()
            }.filter { it.startsWith(args[2].toLowerCase()) }
            else -> emptyList()
        }
    }

    private fun sendHelp(sender: CommandSender) {
        sender.sendMessage("""
            §6Statistics Commands:
            §f/stats system <systemId> [period] - View system statistics
            §f/stats station <stationId> [period] - View station statistics
            §f/stats route <routeId> [period] - View route statistics
            §f/stats report <systemId> <startDate> <endDate> - Generate detailed report
            §f/stats peaks <systemId> - View peak usage times
            §f/stats export <systemId> <type> - Export statistics
            
            §7Periods: daily, weekly, monthly, all_time
        """.trimIndent())
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/command/TransitCommand.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import com.example.transit.model.*
import com.example.transit.statistics.StatisticsManager.StatisticsPeriod
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import java.util.UUID

class TransitCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    override fun onCommand(sender: CommandSender, command: Command, label: String, args: Array<out String>): Boolean {
        if (args.isEmpty()) {
            sendHelp(sender)
            return true
        }

        when (args[0].toLowerCase()) {
            "create" -> handleCreate(sender, args)
            "staff" -> handleStaff(sender, args)
            "stat" -> handleStats(sender, args)
            "config" -> handleConfig(sender, args)
            "info" -> handleInfo(sender, args)
            else -> sendHelp(sender)
        }
        return true
    }

    private fun handleCreate(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.admin")) {
            sender.sendMessage("§cYou don't have permission to create transit systems!")
            return
        }

        if (args.size < 4) {
            sender.sendMessage("§cUsage: /transit create <id> <name> <faretype>")
            return
        }

        val id = args[1]
        val name = args[2]
        val fareType = try {
            FareType.valueOf(args[3].uppercase())
        } catch (e: IllegalArgumentException) {
            sender.sendMessage("§cInvalid fare type! Valid types: ${FareType.values().joinToString()}")
            return
        }

        val system = TransitSystem(
            id = id,
            name = name,
            fareType = fareType,
            fareData = mapOf(),
            maxFare = plugin.config.getDouble("systems.default.maxFare", 5.0)
        )

        if (plugin.configManager.addTransitSystem(system)) {
            sender.sendMessage("§aTransit system created successfully!")
        } else {
            sender.sendMessage("§cFailed to create transit system! ID may already be in use.")
        }
    }

    private fun handleStaff(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.admin")) {
            sender.sendMessage("§cYou don't have permission to manage staff!")
            return
        }

        if (args.size < 4) {
            sender.sendMessage("§cUsage: /transit staff <add/remove/list> <system> [player]")
            return
        }

        val systemId = args[2]
        when (args[1].toLowerCase()) {
            "add" -> {
                if (args.size < 4) {
                    sender.sendMessage("§cUsage: /transit staff add <system> <player> [salary] [role]")
                    return
                }
                
                val player = plugin.server.getPlayer(args[3])
                if (player == null) {
                    sender.sendMessage("§cPlayer not found!")
                    return
                }
                
                val salary = if (args.size > 4) args[4].toDoubleOrNull() ?: 1000.0 else 1000.0
                val role = if (args.size > 5) {
                    try {
                        StaffRole.valueOf(args[5].uppercase())
                    } catch (e: IllegalArgumentException) {
                        StaffRole.TRAINEE
                    }
                } else StaffRole.TRAINEE

                if (plugin.staffManager.addStaffMember(player.uniqueId, systemId, role, salary)) {
                    sender.sendMessage("§aStaff member added successfully!")
                    player.sendMessage("§aYou have been added as a staff member for $systemId")
                } else {
                    sender.sendMessage("§cFailed to add staff member! They may already be staff.")
                }
            }
            "remove" -> {
                val playerId = try {
                    UUID.fromString(args[3])
                } catch (e: IllegalArgumentException) {
                    plugin.server.getPlayer(args[3])?.uniqueId
                }
                
                if (playerId == null) {
                    sender.sendMessage("§cPlayer not found!")
                    return
                }
                
                if (plugin.staffManager.removeStaffMember(playerId, systemId)) {
                    sender.sendMessage("§aStaff member removed successfully!")
                    plugin.server.getPlayer(playerId)?.sendMessage(
                        "§cYou have been removed from staff in system $systemId"
                    )
                } else {
                    sender.sendMessage("§cFailed to remove staff member!")
                }
            }
            "list" -> {
                val staffList = plugin.staffManager.getSystemStaff(systemId)
                if (staffList.isEmpty()) {
                    sender.sendMessage("§cNo staff members found for system $systemId")
                    return
                }
                
                sender.sendMessage("§6Staff members for system $systemId:")
                staffList.forEach { staff ->
                    val playerName = plugin.server.getOfflinePlayer(staff.playerId).name ?: staff.playerId.toString()
                    sender.sendMessage("""
                        §7- $playerName
                          §7Role: §f${staff.role}
                          §7Salary: §f$${staff.salary}
                          §7Payment Period: §f${staff.paymentPeriod}
                    """.trimIndent())
                }
            }
        }
    }

    private fun handleStats(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.stats")) {
            sender.sendMessage("§cYou don't have permission to view statistics!")
            return
        }

        if (args.size < 3) {
            sender.sendMessage("§cUsage: /transit stat <system/station/route> <id> [period]")
            return
        }

        val period = if (args.size > 3) {
            try {
                StatisticsPeriod.valueOf(args[3].uppercase())
            } catch (e: IllegalArgumentException) {
                StatisticsPeriod.ALL_TIME
            }
        } else StatisticsPeriod.ALL_TIME

        when (args[1].toLowerCase()) {
            "system" -> {
                val systemId = args[2]
                val stats = plugin.statisticsManager.getSystemStatistics(systemId, period)
                displayStatistics(sender, "System", systemId, stats, period)
            }
            "station" -> {
                val stationId = args[2]
                val stats = plugin.statisticsManager.getStationStatistics(stationId, period)
                displayStatistics(sender, "Station", stationId, stats, period)
            }
            "route" -> {
                val routeId = args[2]
                val stats = plugin.statisticsManager.getRouteStatistics(routeId, period)
                displayStatistics(sender, "Route", routeId, stats, period)
            }
            else -> sender.sendMessage("§cInvalid statistics type! Use: system, station, or route")
        }
    }

    private fun handleConfig(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.admin")) {
            sender.sendMessage("§cYou don't have permission to manage configuration!")
            return
        }

        if (args.size < 2) {
            sender.sendMessage("§cUsage: /transit config <reload/save>")
            return
        }

        when (args[1].toLowerCase()) {
            "reload" -> {
                plugin.reloadConfig()
                sender.sendMessage("§aConfiguration reloaded successfully!")
            }
            "save" -> {
                plugin.saveConfig()
                sender.sendMessage("§aConfiguration saved successfully!")
            }
            else -> sender.sendMessage("§cInvalid config action! Use: reload or save")
        }
    }

    private fun handleInfo(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /transit info <system>")
            return
        }

        val system = plugin.configManager.getTransitSystem(args[1])
        if (system == null) {
            sender.sendMessage("§cSystem not found!")
            return
        }

        sender.sendMessage("""
            §6System Information: §f${system.name}
            §7ID: §f${system.id}
            §7Fare Type: §f${system.fareType}
            §7Maximum Fare: §f${system.maxFare.formatCurrency()}
            §7Stations: §f${plugin.stationManager.getSystemStations(system.id).size}
            §7Routes: §f${plugin.routeManager.getSystemRoutes(system.id).size}
            §7Staff Members: §f${plugin.staffManager.getSystemStaff(system.id).size}
        """.trimIndent())
    }

    private fun displayStatistics(
        sender: CommandSender,
        type: String,
        id: String,
        stats: StatisticsManager.Statistics?,
        period: StatisticsPeriod
    ) {
        if (stats == null) {
            sender.sendMessage("§cNo statistics found for $type $id")
            return
        }

        sender.sendMessage("""
            §6$type Statistics ($id) - $period
            §7Total Revenue: §f${stats.totalRevenue.formatCurrency()}
            §7Total Transactions: §f${stats.totalTransactions}
            §7Average Transaction: §f${(stats.totalRevenue / stats.totalTransactions).formatCurrency()}
            §7Last Updated: §f${stats.lastUpdated}
        """.trimIndent())
    }

    override fun onTabComplete(
        sender: CommandSender,
        command: Command,
        alias: String,
        args: Array<out String>
    ): List<String> {
        return when (args.size) {
            1 -> listOf("create", "staff", "stat", "config", "info")
                .filter { it.startsWith(args[0].toLowerCase()) }
            2 -> when (args[0].toLowerCase()) {
                "staff" -> listOf("add", "remove", "list")
                "stat" -> listOf("system", "station", "route")
                "config" -> listOf("reload", "save")
                "info", "stat" -> plugin.configManager.getSystems().map { it.id }
                else -> emptyList()
            }.filter { it.startsWith(args[1].toLowerCase()) }
            3 -> when {
                args[0].equals("staff", true) -> plugin.configManager.getSystems().map { it.id }
                args[0].equals("stat", true) -> when (args[1].toLowerCase()) {
                    "system" -> plugin.configManager.getSystems().map { it.id }
                    "station" -> plugin.stationManager.getAllStations().map { it.id }
                    "route" -> plugin.routeManager.getRoutes()
                    else -> emptyList()
                }
                else -> emptyList()
            }.filter { it.startsWith(args[2].toLowerCase()) }
            4 -> when {
                args[0].equals("stat", true) -> StatisticsPeriod.values()
                    .map { it.name.toLowerCase() }
                    .filter { it.startsWith(args[3].toLowerCase()) }
                else -> emptyList()
            }
            else -> emptyList()
        }
    }

    private fun Double.formatCurrency(): String = "$${String.format("%.2f", this)}"

    private fun sendHelp(sender: CommandSender) {
        sender.sendMessage("""
            §6Transit Commands:
            §f/transit create <id> <name> <faretype> - Create a transit system
            §f/transit staff <add/remove/list> <system> [player] - Manage staff
            §f/transit stat <system/station/route> <id> [period] - View statistics
            §f/transit config <reload/save> - Manage configuration
            §f/transit info <system> - View system information
        """.trimIndent())
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/config/ConfigManager.kt">
package com.example.transit.config

import com.example.transit.TransitPlugin
import com.example.transit.model.FareType
import com.example.transit.model.TransitSystem
import org.bukkit.configuration.ConfigurationSection
import java.io.File

class ConfigManager(private val plugin: TransitPlugin) {
    private val systems = mutableMapOf<String, TransitSystem>()
    private val messages = Messages(plugin)

    init {
        loadSystems()
    }

    fun getTransitSystem(id: String): TransitSystem? = systems[id]
    
    fun getSystems(): List<TransitSystem> = systems.values.toList()

    fun getMessage(key: String, vararg params: Pair<String, String>): String {
        return messages.get(key, params.toMap())
    }

    private fun loadSystems() {
        val systemsSection = plugin.config.getConfigurationSection("systems") ?: return
        
        for (systemId in systemsSection.getKeys(false)) {
            val section = systemsSection.getConfigurationSection(systemId) ?: continue
            
            try {
                systems[systemId] = TransitSystem(
                    id = systemId,
                    name = section.getString("name") ?: systemId,
                    fareType = FareType.valueOf(section.getString("fareType", "FLAT")!!.uppercase()),
                    fareData = loadFareData(section),
                    maxFare = section.getDouble("maxFare", 5.0)
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load system $systemId: ${e.message}")
            }
        }
    }

    private fun loadFareData(section: ConfigurationSection): Map<String, Any> {
        return when (FareType.valueOf(section.getString("fareType", "FLAT")!!.uppercase())) {
            FareType.ZONE -> loadZoneFareData(section)
            FareType.FLAT -> mapOf("fare" to section.getDouble("fare", 2.75))
            FareType.DISTANCE -> mapOf(
                "baseRate" to section.getDouble("baseRate", 2.0),
                "perBlock" to section.getDouble("perBlock", 0.01)
            )
        }
    }

    private fun loadZoneFareData(section: ConfigurationSection): Map<String, Any> {
        val fareData = mutableMapOf<String, Any>()
        
        section.getConfigurationSection("zones")?.let { zonesSection ->
            fareData["rings"] = loadZoneRings(zonesSection)
            fareData["groups"] = loadZoneGroups(zonesSection)
            fareData["rules"] = loadZoneRules(zonesSection)
        }
        
        return fareData
    }

    private fun loadZoneRings(section: ConfigurationSection): Map<String, Int> {
        val rings = mutableMapOf<String, Int>()
        section.getConfigurationSection("rings")?.let { ringsSection ->
            for (zone in ringsSection.getKeys(false)) {
                rings[zone] = ringsSection.getInt(zone)
            }
        }
        return rings
    }

    private fun loadZoneGroups(section: ConfigurationSection): Map<String, List<String>> {
        val groups = mutableMapOf<String, List<String>>()
        section.getConfigurationSection("groups")?.let { groupsSection ->
            for (group in groupsSection.getKeys(false)) {
                groups[group] = groupsSection.getStringList(group)
            }
        }
        return groups
    }

    private fun loadZoneRules(section: ConfigurationSection): List<Map<String, Any>> {
        val rules = mutableListOf<Map<String, Any>>()
        section.getConfigurationSection("rules")?.let { rulesSection ->
            for (rule in rulesSection.getKeys(false)) {
                val ruleSection = rulesSection.getConfigurationSection(rule) ?: continue
                rules.add(mapOf(
                    "from" to (ruleSection.getString("from") ?: ""),
                    "to" to (ruleSection.getString("to") ?: ""),
                    "fare" to ruleSection.getDouble("fare"),
                    "ringDifference" to ruleSection.getInt("ringDifference", -1),
                    "fromGroup" to (ruleSection.getString("fromGroup") ?: ""),
                    "toGroup" to (ruleSection.getString("toGroup") ?: ""),
                    "crossGroup" to ruleSection.getBoolean("crossGroup", false)
                ))
            }
        }
        return rules
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/config/Messages.kt">
package com.example.transit.config

import org.bukkit.configuration.file.YamlConfiguration
import org.bukkit.plugin.Plugin
import java.io.File

class Messages(plugin: Plugin) {
    private val messages: YamlConfiguration

    init {
        val messageFile = File(plugin.dataFolder, "messages.yml")
        if (!messageFile.exists()) {
            plugin.saveResource("messages.yml", false)
        }
        messages = YamlConfiguration.loadConfiguration(messageFile)
    }

    fun get(key: String, params: Map<String, String> = emptyMap()): String {
        var message = messages.getString(key) ?: return "§cMissing message: $key"
        params.forEach { (key, value) ->
            message = message.replace("{$key}", value)
        }
        return message.replace("&", "§")
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/conversation/GateSetupConversation.kt">
package com.example.transit.conversation

import com.example.transit.TransitPlugin
import com.example.transit.model.Gate
import org.bukkit.Location
import org.bukkit.conversations.*
import org.bukkit.entity.Player

class GateSetupConversation(
    private val plugin: TransitPlugin,
    private val location: Location,
    private val player: Player
) {
    private var lastSystem: String? = null
    private var lastStation: String? = null

    fun start() {
        val factory = ConversationFactory(plugin)
            .withModality(true)
            .withFirstPrompt(SystemPrompt())
            .withEscapeSequence("cancel")
            .withTimeout(60)
            .withLocalEcho(false)
            .addConversationAbandonedListener { event ->
                if (!event.gracefulExit()) {
                    player.sendMessage("§cGate setup cancelled!")
                }
            }

        factory.buildConversation(player).begin()
    }

    private inner class SystemPrompt : ValidatingPrompt() {
        override fun getPromptText(context: ConversationContext): String {
            val systems = plugin.configManager.getSystems().map { it.id }
            return if (lastSystem != null) {
                "§6Enter system ID or press Enter to use last system (${lastSystem}):\n" +
                "§7Available systems: ${systems.joinToString(", ")}"
            } else {
                "§6Enter system ID:\n§7Available systems: ${systems.joinToString(", ")}"
            }
        }

        override fun isInputValid(context: ConversationContext, input: String): Boolean {
            val systemId = if (input.isEmpty()) lastSystem else input
            return systemId?.let { plugin.configManager.getTransitSystem(it) != null } ?: false
        }

        override fun acceptValidatedInput(context: ConversationContext, input: String): Prompt {
            val systemId = if (input.isEmpty()) lastSystem!! else input
            context.setSessionData("system", systemId)
            lastSystem = systemId
            return StationPrompt()
        }

        override fun getFailedValidationText(context: ConversationContext, invalidInput: String): String {
            return "§cInvalid system ID! Please try again."
        }
    }

    private inner class StationPrompt : ValidatingPrompt() {
        override fun getPromptText(context: ConversationContext): String {
            val systemId = context.getSessionData("system") as String
            val stations = plugin.stationManager.getSystemStations(systemId).map { it.name }
            return if (lastStation != null) {
                "§6Enter station name or press Enter to use last station (${lastStation}):\n" +
                "§7Available stations: ${stations.joinToString(", ")}"
            } else {
                "§6Enter station name:\n§7Available stations: ${stations.joinToString(", ")}"
            }
        }

        override fun isInputValid(context: ConversationContext, input: String): Boolean {
            val systemId = context.getSessionData("system") as String
            val stationId = if (input.isEmpty()) lastStation else input
            return stationId?.let { 
                plugin.stationManager.getStation("${systemId}_${it.toLowerCase()}") != null 
            } ?: false
        }

        override fun acceptValidatedInput(context: ConversationContext, input: String): Prompt? {
            val systemId = context.getSessionData("system") as String
            val stationId = if (input.isEmpty()) lastStation!! else input
            
            // Create the gate
            createGate(
                systemId,
                "${systemId}_${stationId.toLowerCase()}"
            )
            
            context.forWhom.sendRawMessage("§aFare gate created successfully!")
            lastStation = stationId
            return null
        }

        override fun getFailedValidationText(context: ConversationContext, invalidInput: String): String {
            return "§cInvalid station name! Please try again."
        }
    }

    private fun createGate(systemId: String, stationId: String) {
        val gate = Gate(
            id = "${systemId}_${location.blockX}_${location.blockY}_${location.blockZ}",
            location = location,
            systemId = systemId,
            stationId = stationId
        )
        plugin.gateManager.registerGate(gate)
        
        // Update the sign text
        val sign = location.block.state as? org.bukkit.block.Sign
        sign?.let {
            val station = plugin.stationManager.getStation(stationId)
            it.setLine(0, "§1[Fare]")
            it.setLine(1, station?.name ?: "Unknown Station")
            it.setLine(2, "§aActive")
            it.setLine(3, station?.zone ?: "")
            it.update()
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/event/TransitEvents.kt">
package com.example.transit.event

import com.example.transit.model.Station
import com.example.transit.model.Transaction
import org.bukkit.entity.Player
import org.bukkit.event.Event
import org.bukkit.event.HandlerList
import org.bukkit.event.Cancellable

class TransitGateEntryEvent(
    val player: Player,
    val station: Station,
    val fareAmount: Double
) : Event(), Cancellable {
    private var cancelled = false
    
    override fun isCancelled() = cancelled
    override fun setCancelled(cancel: Boolean) { cancelled = cancel }
    
    companion object {
        private val handlers = HandlerList()
        @JvmStatic
        fun getHandlerList() = handlers
    }
    override fun getHandlers() = getHandlerList()
}

class TransitGateExitEvent(
    val player: Player,
    val fromStation: Station,
    val toStation: Station,
    val fareAmount: Double,
    val transaction: Transaction
) : Event(), Cancellable {
    private var cancelled = false
    
    override fun isCancelled() = cancelled
    override fun setCancelled(cancel: Boolean) { cancelled = cancel }
    
    companion object {
        private val handlers = HandlerList()
        @JvmStatic
        fun getHandlerList() = handlers
    }
    override fun getHandlers() = getHandlerList()
}

class TransitStaffPaymentEvent(
    val player: Player,
    val systemId: String,
    val amount: Double
) : Event(), Cancellable {
    private var cancelled = false
    
    override fun isCancelled() = cancelled
    override fun setCancelled(cancel: Boolean) { cancelled = cancel }
    
    companion object {
        private val handlers = HandlerList()
        @JvmStatic
        fun getHandlerList() = handlers
    }
    override fun getHandlers() = getHandlerList()
}
</file>

<file path="src/main/kotlin/com/example/transit/event/TransitListener.kt">
package com.example.transit.event

import com.example.transit.TransitPlugin
import org.bukkit.event.EventHandler
import org.bukkit.event.EventPriority
import org.bukkit.event.Listener
import org.bukkit.event.player.PlayerJoinEvent
import org.bukkit.event.player.PlayerQuitEvent
import org.bukkit.event.server.PluginDisableEvent
import org.bukkit.event.server.ServerLoadEvent
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

class TransitListener(private val plugin: TransitPlugin) : Listener {

    @EventHandler
    fun onPlayerJoin(event: PlayerJoinEvent) {
        // Check for pending staff payments
        if (plugin.staffManager.isStaffAnywhere(event.player.uniqueId)) {
            plugin.staffManager.checkPendingPayments(event.player)
        }

        // Check for incomplete journeys
        checkIncompleteJourneys(event.player)
    }

    @EventHandler
    fun onPlayerQuit(event: PlayerQuitEvent) {
        handlePlayerQuit(event.player)
    }

    @EventHandler(priority = EventPriority.MONITOR)
    fun onServerLoad(event: ServerLoadEvent) {
        if (event.type == ServerLoadEvent.LoadType.RELOAD) {
            plugin.logger.warning("Plugin reloaded - Some features may not work correctly until a full restart")
        }
    }

    @EventHandler
    fun onPluginDisable(event: PluginDisableEvent) {
        if (event.plugin.name == "Vault") {
            plugin.logger.severe("Vault plugin disabled - Transit plugin may not function correctly!")
        }
    }

    private fun checkIncompleteJourneys(player: org.bukkit.entity.Player) {
        val activeJourney = plugin.fareManager.getActiveJourney(player.uniqueId)
        if (activeJourney != null) {
            val timeSinceStart = ChronoUnit.MINUTES.between(
                activeJourney.startTime,
                LocalDateTime.now()
            )
            
            if (timeSinceStart > plugin.config.getLong("settings.maxTapDuration", 120)) {
                // Journey exceeded maximum duration, apply maximum fare
                val system = plugin.configManager.getTransitSystem(activeJourney.systemId)
                if (system != null) {
                    plugin.fareManager.chargeMaximumFare(player, system)
                }
                plugin.fareManager.clearActiveJourney(player.uniqueId)
            }
        }
    }

    private fun handlePlayerQuit(player: org.bukkit.entity.Player) {
        val activeJourney = plugin.fareManager.getActiveJourney(player.uniqueId)
        if (activeJourney != null) {
            val system = plugin.configManager.getTransitSystem(activeJourney.systemId)
            if (system != null) {
                // Player quit with active journey, charge maximum fare
                plugin.fareManager.chargeMaximumFare(player, system)
            }
            plugin.fareManager.clearActiveJourney(player.uniqueId)
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/fare/ZoneFareCalculator.kt">
package com.example.transit.fare

import org.bukkit.configuration.ConfigurationSection
import kotlin.math.abs

class ZoneFareCalculator(config: ConfigurationSection) {
    private val zoneRings = mutableMapOf<String, Int>()
    private val zoneGroups = mutableMapOf<String, Set<String>>()
    private val fareRules = mutableListOf<FareRule>()
    private val defaultFare: Double
    private val peakHours: Set<Int>
    private val peakMultiplier: Double
    private val specialFares = mutableMapOf<String, Double>() // For student, senior rates etc
    
    init {
        defaultFare = config.getDouble("defaultFare", 5.0)
        peakHours = config.getIntegerList("peakHours").toSet()
        peakMultiplier = config.getDouble("peakMultiplier", 1.5)
        loadZoneConfiguration(config)
        loadSpecialFares(config)
    }

    fun calculateFare(
        fromZone: String, 
        toZone: String, 
        hour: Int = -1,
        fareType: String = "STANDARD"
    ): Double {
        // Try exact zone match first
        var baseFare = fareRules.firstOrNull { rule -> 
            rule.matches(fromZone, toZone)
        }?.fare

        // Try ring-based calculation if no exact match
        if (baseFare == null && zoneRings.containsKey(fromZone) && zoneRings.containsKey(toZone)) {
            val ringDifference = abs(zoneRings[fromZone]!! - zoneRings[toZone]!!)
            baseFare = fareRules.firstOrNull { rule -> 
                rule.matchesRingDifference(ringDifference)
            }?.fare
        }

        // Try group-based rules if still no match
        if (baseFare == null) {
            val fromGroups = findZoneGroups(fromZone)
            val toGroups = findZoneGroups(toZone)
            if (fromGroups.isNotEmpty() && toGroups.isNotEmpty()) {
                baseFare = fareRules.firstOrNull { rule ->
                    fromGroups.contains(rule.fromGroup) && toGroups.contains(rule.toGroup)
                }?.fare
            }
        }

        // Use default fare if no rules match
        baseFare = baseFare ?: defaultFare

        // Apply peak hour multiplier if applicable
        if (hour in peakHours) {
            baseFare *= peakMultiplier
        }

        // Apply special fare rate if applicable
        val specialRate = specialFares[fareType]
        if (specialRate != null) {
            baseFare *= specialRate
        }

        return baseFare
    }

    fun isPeakHour(hour: Int): Boolean = hour in peakHours

    fun getAvailableFareTypes(): Set<String> = specialFares.keys + "STANDARD"

    private fun loadZoneConfiguration(config: ConfigurationSection) {
        // Load zone rings
        config.getConfigurationSection("rings")?.let { ringsSection ->
            for (zone in ringsSection.getKeys(false)) {
                zoneRings[zone] = ringsSection.getInt(zone)
            }
        }

        // Load zone groups
        config.getConfigurationSection("groups")?.let { groupsSection ->
            for (groupName in groupsSection.getKeys(false)) {
                zoneGroups[groupName] = groupsSection.getStringList(groupName).toSet()
            }
        }

        // Load fare rules
        config.getConfigurationSection("rules")?.let { rulesSection ->
            for (ruleKey in rulesSection.getKeys(false)) {
                val ruleSection = rulesSection.getConfigurationSection(ruleKey)
                ruleSection?.let {
                    fareRules.add(FareRule(
                        fromPattern = it.getString("from"),
                        toPattern = it.getString("to"),
                        fare = it.getDouble("fare"),
                        ringDifference = if (it.contains("ringDifference")) it.getInt("ringDifference") else null,
                        fromGroup = it.getString("fromGroup"),
                        toGroup = it.getString("toGroup"),
                        crossGroup = it.getBoolean("crossGroup", false),
                        timeRestriction = loadTimeRestriction(it)
                    ))
                }
            }
        }
    }

    private fun loadSpecialFares(config: ConfigurationSection) {
        config.getConfigurationSection("specialFares")?.let { specialSection ->
            for (fareType in specialSection.getKeys(false)) {
                specialFares[fareType] = specialSection.getDouble(fareType)
            }
        }
    }

    private fun loadTimeRestriction(config: ConfigurationSection): TimeRestriction? {
        return if (config.contains("timeRestriction")) {
            val timeSection = config.getConfigurationSection("timeRestriction")
            TimeRestriction(
                startHour = timeSection?.getInt("startHour") ?: 0,
                endHour = timeSection?.getInt("endHour") ?: 23,
                daysOfWeek = timeSection?.getIntegerList("daysOfWeek")?.toSet() ?: setOf()
            )
        } else null
    }

    private fun findZoneGroups(zone: String): Set<String> {
        return zoneGroups.filterValues { it.contains(zone) }.keys
    }

    fun getZoneRing(zone: String): Int? = zoneRings[zone]
    
    fun isZoneInGroup(zone: String, group: String): Boolean {
        return zoneGroups[group]?.contains(zone) ?: false
    }

    data class TimeRestriction(
        val startHour: Int,
        val endHour: Int,
        val daysOfWeek: Set<Int>
    )

    data class FareRule(
        val fromPattern: String?,
        val toPattern: String?,
        val fare: Double,
        val ringDifference: Int?,
        val fromGroup: String?,
        val toGroup: String?,
        val crossGroup: Boolean,
        val timeRestriction: TimeRestriction?
    ) {
        fun matches(fromZone: String, toZone: String): Boolean {
            if (fromPattern == null || toPattern == null) return false
            return fromZone.matches(fromPattern.toRegex()) && 
                   toZone.matches(toPattern.toRegex())
        }

        fun matchesRingDifference(difference: Int): Boolean {
            return ringDifference != null && ringDifference == difference
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/listener/GateListener.kt">
package com.example.transit.listener

import com.example.transit.TransitPlugin
import com.example.transit.model.Gate
import org.bukkit.Material
import org.bukkit.block.Sign
import org.bukkit.event.EventHandler
import org.bukkit.event.Listener
import org.bukkit.event.block.Action
import org.bukkit.event.block.BlockBreakEvent
import org.bukkit.event.block.SignChangeEvent
import org.bukkit.event.player.PlayerInteractEvent

class GateListener(private val plugin: TransitPlugin) : Listener {
    
    @EventHandler
    fun onSignCreate(event: SignChangeEvent) {
        if (event.getLine(0)?.equals("[Fare]", true) != true) return
        
        if (!event.player.hasPermission("transit.admin")) {
            event.player.sendMessage("§cYou don't have permission to create fare gates!")
            event.isCancelled = true
            return
        }

        // Format the sign
        event.setLine(0, "§1[Fare]")
        
        // Start gate creation conversation
        plugin.gateManager.startGateCreation(event.player, event.block.location)
    }

    @EventHandler
    fun onSignBreak(event: BlockBreakEvent) {
        val block = event.block
        if (block.type != Material.OAK_WALL_SIGN && 
            block.type != Material.OAK_SIGN) return
            
        val sign = block.state as? Sign ?: return
        if (sign.getLine(0) != "§1[Fare]") return
        
        if (!event.player.hasPermission("transit.admin")) {
            event.player.sendMessage("§cYou don't have permission to remove fare gates!")
            event.isCancelled = true
            return
        }
        
        // Remove the gate
        plugin.gateManager.removeGate(block.location)
        event.player.sendMessage("§aFare gate removed!")
    }

    @EventHandler
    fun onGateInteract(event: PlayerInteractEvent) {
        if (event.action != Action.RIGHT_CLICK_BLOCK) return
        val block = event.clickedBlock ?: return
        if (block.type != Material.OAK_WALL_SIGN && 
            block.type != Material.OAK_SIGN) return
        
        val sign = block.state as? Sign ?: return
        if (sign.getLine(0) != "§1[Fare]") return

        event.isCancelled = true
        
        // Handle gate interaction
        val gate = plugin.gateManager.getGateAtLocation(block.location)
        if (gate != null) {
            handleGateInteraction(event.player, gate)
        }
    }
    
    private fun handleGateInteraction(player: org.bukkit.entity.Player, gate: Gate) {
        // Check if player has an active journey
        val activeJourney = plugin.fareManager.getActiveJourney(player.uniqueId)
        
        if (activeJourney == null) {
            // Start new journey
            if (plugin.fareManager.handleTapIn(player, gate.systemId, gate.stationId)) {
                playGateEffect(gate, true)
            }
        } else {
            // End journey
            if (plugin.fareManager.handleTapOut(player, gate.systemId, gate.stationId)) {
                playGateEffect(gate, true)
            } else {
                playGateEffect(gate, false)
            }
        }
    }
    
    private fun playGateEffect(gate: Gate, success: Boolean) {
        val location = gate.location
        if (plugin.config.getBoolean("gates.soundEffects", true)) {
            location.world?.playSound(
                location,
                if (success) org.bukkit.Sound.BLOCK_NOTE_BLOCK_PLING else org.bukkit.Sound.BLOCK_NOTE_BLOCK_BASS,
                1f,
                if (success) 2f else 0.5f
            )
        }
        
        if (plugin.config.getBoolean("gates.particleEffects", true)) {
            location.world?.spawnParticle(
                if (success) org.bukkit.Particle.VILLAGER_HAPPY else org.bukkit.Particle.VILLAGER_ANGRY,
                location.add(0.5, 1.0, 0.5),
                5,
                0.2,
                0.2,
                0.2,
                0.0
            )
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/ConfigManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.TransitSystem
import com.example.transit.model.FareType
import org.bukkit.configuration.ConfigurationSection

class ConfigManager(private val plugin: TransitPlugin) {
    private val systems = mutableMapOf<String, TransitSystem>()
    
    init {
        loadSystems()
    }

    fun reload() {
        systems.clear()
        loadSystems()
    }

    fun reloadConfig() {
        plugin.reloadConfig()
        reload()
    }

    fun getTransitSystem(id: String): TransitSystem? = systems[id]
    
    fun getSystems(): List<TransitSystem> = systems.values.toList()

    fun addTransitSystem(system: TransitSystem): Boolean {
        if (systems.containsKey(system.id)) return false
        
        systems[system.id] = system
        
        // Save to config
        val section = plugin.config.createSection("systems.${system.id}")
        section.set("name", system.name)
        section.set("fareType", system.fareType.name)
        section.set("maxFare", system.maxFare)
        
        // Save fare data based on type
        when (system.fareType) {
            FareType.FLAT -> {
                section.set("fare", system.fareData["fare"])
            }
            FareType.DISTANCE -> {
                section.set("baseRate", system.fareData["baseRate"])
                section.set("perBlock", system.fareData["perBlock"])
            }
            FareType.ZONE -> {
                val zonesSection = section.createSection("zones")
                val fareData = system.fareData
                
                // Save rings
                @Suppress("UNCHECKED_CAST")
                val rings = fareData["rings"] as? Map<String, Int>
                if (rings != null) {
                    val ringsSection = zonesSection.createSection("rings")
                    rings.forEach { (zone, ring) ->
                        ringsSection.set(zone, ring)
                    }
                }
                
                // Save groups
                @Suppress("UNCHECKED_CAST")
                val groups = fareData["groups"] as? Map<String, List<String>>
                if (groups != null) {
                    val groupsSection = zonesSection.createSection("groups")
                    groups.forEach { (name, zones) ->
                        groupsSection.set(name, zones)
                    }
                }
                
                // Save rules
                @Suppress("UNCHECKED_CAST")
                val rules = fareData["rules"] as? List<Map<String, Any>>
                if (rules != null) {
                    val rulesSection = zonesSection.createSection("rules")
                    rules.forEachIndexed { index, rule ->
                        val ruleSection = rulesSection.createSection(index.toString())
                        rule.forEach { (key, value) ->
                            ruleSection.set(key, value)
                        }
                    }
                }
            }
        }
        
        plugin.saveConfig()
        return true
    }

    private fun loadSystems() {
        val systemsSection = plugin.config.getConfigurationSection("systems") ?: return
        
        for (systemId in systemsSection.getKeys(false)) {
            val section = systemsSection.getConfigurationSection(systemId) ?: continue
            
            try {
                systems[systemId] = TransitSystem(
                    id = systemId,
                    name = section.getString("name") ?: systemId,
                    fareType = FareType.valueOf(section.getString("fareType", "FLAT")!!.uppercase()),
                    fareData = loadFareData(section),
                    maxFare = section.getDouble("maxFare", 5.0)
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load system $systemId: ${e.message}")
            }
        }
    }

    private fun loadFareData(section: ConfigurationSection): Map<String, Any> {
        return when (FareType.valueOf(section.getString("fareType", "FLAT")!!.uppercase())) {
            FareType.ZONE -> loadZoneFareData(section)
            FareType.FLAT -> mapOf("fare" to section.getDouble("fare", 2.75))
            FareType.DISTANCE -> mapOf(
                "baseRate" to section.getDouble("baseRate", 2.0),
                "perBlock" to section.getDouble("perBlock", 0.01)
            )
        }
    }

    private fun loadZoneFareData(section: ConfigurationSection): Map<String, Any> {
        val fareData = mutableMapOf<String, Any>()
        section.getConfigurationSection("zones")?.let { zones ->
            fareData["rings"] = loadZoneRings(zones)
            fareData["groups"] = loadZoneGroups(zones)
            fareData["rules"] = loadZoneRules(zones)
        }
        return fareData
    }

    private fun loadZoneRings(section: ConfigurationSection): Map<String, Int> {
        val rings = mutableMapOf<String, Int>()
        section.getConfigurationSection("rings")?.let { ringsSection ->
            for (zone in ringsSection.getKeys(false)) {
                rings[zone] = ringsSection.getInt(zone)
            }
        }
        return rings
    }

    private fun loadZoneGroups(section: ConfigurationSection): Map<String, List<String>> {
        val groups = mutableMapOf<String, List<String>>()
        section.getConfigurationSection("groups")?.let { groupsSection ->
            for (group in groupsSection.getKeys(false)) {
                groups[group] = groupsSection.getStringList(group)
            }
        }
        return groups
    }

    private fun loadZoneRules(section: ConfigurationSection): List<Map<String, Any>> {
        val rules = mutableListOf<Map<String, Any>>()
        section.getConfigurationSection("rules")?.let { rulesSection ->
            for (rule in rulesSection.getKeys(false)) {
                val ruleSection = rulesSection.getConfigurationSection(rule) ?: continue
                rules.add(mapOf(
                    "from" to (ruleSection.getString("from") ?: ""),
                    "to" to (ruleSection.getString("to") ?: ""),
                    "fare" to ruleSection.getDouble("fare"),
                    "ringDifference" to ruleSection.getInt("ringDifference", -1),
                    "fromGroup" to (ruleSection.getString("fromGroup") ?: ""),
                    "toGroup" to (ruleSection.getString("toGroup") ?: ""),
                    "crossGroup" to ruleSection.getBoolean("crossGroup", false)
                ))
            }
        }
        return rules
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/DatabaseManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.Transaction
import com.example.transit.model.TransactionType
import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource
import java.sql.Connection
import java.sql.SQLException
import java.time.LocalDateTime
import java.util.UUID

class DatabaseManager(private val plugin: TransitPlugin) {
    private var dataSource: HikariDataSource? = null
    
    init {
        if (plugin.config.getString("database.type")?.uppercase() == "MYSQL") {
            setupHikari()
            createTables()
        }
    }

    private fun createTables() {
        executeUpdate("""
            CREATE TABLE IF NOT EXISTS ${getTableName("transactions")} (
                id VARCHAR(36) PRIMARY KEY,
                player_id VARCHAR(36) NOT NULL,
                system_id VARCHAR(50) NOT NULL,
                from_station VARCHAR(50) NOT NULL,
                to_station VARCHAR(50),
                amount DECIMAL(10,2) NOT NULL,
                type VARCHAR(20) NOT NULL,
                timestamp DATETIME NOT NULL,
                INDEX idx_player (player_id),
                INDEX idx_system (system_id),
                INDEX idx_timestamp (timestamp)
            )
        """)

        executeUpdate("""
            CREATE TABLE IF NOT EXISTS ${getTableName("statistics")} (
                id VARCHAR(36) PRIMARY KEY,
                type VARCHAR(20) NOT NULL,
                reference_id VARCHAR(50) NOT NULL,
                total_revenue DECIMAL(10,2) NOT NULL DEFAULT 0,
                total_transactions INT NOT NULL DEFAULT 0,
                last_updated DATETIME NOT NULL,
                INDEX idx_type_ref (type, reference_id)
            )
        """)
    }

    private fun setupHikari() {
        val config = HikariConfig().apply {
            jdbcUrl = buildJdbcUrl()
            username = plugin.config.getString("database.mysql.username")
            password = plugin.config.getString("database.mysql.password")
            maximumPoolSize = 10
            minimumIdle = 2
            idleTimeout = 300000
            connectionTimeout = 10000
            validationTimeout = 5000
        }

        try {
            dataSource = HikariDataSource(config)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to initialize database connection: ${e.message}")
        }
    }

    private fun buildJdbcUrl(): String {
        val host = plugin.config.getString("database.mysql.host", "localhost")
        val port = plugin.config.getInt("database.mysql.port", 3306)
        val database = plugin.config.getString("database.mysql.database", "transit")
        
        return "jdbc:mysql://$host:$port/$database?useSSL=false&serverTimezone=UTC"
    }

    fun saveTransaction(transaction: Transaction) {
        executeUpdate("""
            INSERT INTO ${getTableName("transactions")} 
            (id, player_id, system_id, from_station, to_station, amount, type, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """) { stmt ->
            stmt.setString(1, transaction.id)
            stmt.setString(2, transaction.playerId.toString())
            stmt.setString(3, transaction.systemId)
            stmt.setString(4, transaction.fromStation)
            stmt.setString(5, transaction.toStation)
            stmt.setDouble(6, transaction.amount)
            stmt.setString(7, transaction.type.name)
            stmt.setString(8, transaction.timestamp.toString())
        }
    }

    private fun getTableName(base: String): String {
        val prefix = plugin.config.getString("database.mysql.prefix", "transit_")
        return "$prefix$base"
    }

    private fun executeUpdate(sql: String, prepare: (java.sql.PreparedStatement) -> Unit = {}) {
        try {
            dataSource?.connection?.use { conn ->
                conn.prepareStatement(sql).use { stmt ->
                    prepare(stmt)
                    stmt.executeUpdate()
                }
            }
        } catch (e: SQLException) {
            plugin.logger.severe("Failed to execute update: ${e.message}")
            e.printStackTrace()
        }
    }

    fun getTransactions(
        systemId: String? = null,
        playerId: UUID? = null,
        startTime: LocalDateTime? = null,
        endTime: LocalDateTime? = null
    ): List<Transaction> {
        val conditions = mutableListOf<String>()
        val params = mutableListOf<Any>()

        systemId?.let {
            conditions.add("system_id = ?")
            params.add(it)
        }
        playerId?.let {
            conditions.add("player_id = ?")
            params.add(it.toString())
        }
        startTime?.let {
            conditions.add("timestamp >= ?")
            params.add(it.toString())
        }
        endTime?.let {
            conditions.add("timestamp <= ?")
            params.add(it.toString())
        }

        val whereClause = if (conditions.isNotEmpty()) 
            "WHERE ${conditions.joinToString(" AND ")}" else ""

        val sql = """
            SELECT * FROM ${getTableName("transactions")} 
            $whereClause 
            ORDER BY timestamp DESC
        """

        return executeQuery(sql, params) { rs ->
            Transaction(
                id = rs.getString("id"),
                playerId = UUID.fromString(rs.getString("player_id")),
                systemId = rs.getString("system_id"),
                fromStation = rs.getString("from_station"),
                toStation = rs.getString("to_station"),
                amount = rs.getDouble("amount"),
                type = TransactionType.valueOf(rs.getString("type")),
                timestamp = LocalDateTime.parse(rs.getString("timestamp"))
            )
        }
    }

    private fun <T> executeQuery(
        sql: String,
        params: List<Any> = emptyList(),
        mapper: (java.sql.ResultSet) -> T
    ): List<T> {
        val results = mutableListOf<T>()
        try {
            dataSource?.connection?.use { conn ->
                conn.prepareStatement(sql).use { stmt ->
                    params.forEachIndexed { index, param ->
                        stmt.setObject(index + 1, param)
                    }
                    val rs = stmt.executeQuery()
                    while (rs.next()) {
                        results.add(mapper(rs))
                    }
                }
            }
        } catch (e: SQLException) {
            plugin.logger.severe("Failed to execute query: ${e.message}")
            e.printStackTrace()
        }
        return results
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/FareManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.*
import com.example.transit.fare.ZoneFareCalculator
import net.milkbowl.vault.economy.Economy
import org.bukkit.entity.Player
import java.time.LocalDateTime
import java.util.*
import java.util.concurrent.ConcurrentHashMap

class FareManager(
    private val plugin: TransitPlugin,
    private val economy: Economy
) {
    private val activeTaps = ConcurrentHashMap<UUID, TapData>()
    private val activeJourneys = ConcurrentHashMap<UUID, JourneyData>()
    private val zoneFareCalculator = ZoneFareCalculator(plugin.config.getConfigurationSection("systems") 
        ?: throw IllegalStateException("Missing systems configuration"))
    
    fun getActiveJourney(playerId: UUID): JourneyData? = activeJourneys[playerId]

    fun clearActiveJourney(playerId: UUID) {
        activeJourneys.remove(playerId)
    }

    fun handleTapIn(player: Player, systemId: String, stationId: String): Boolean {
        val station = plugin.stationManager.getStation(stationId) ?: return false
        val system = plugin.configManager.getTransitSystem(systemId) ?: return false

        when (system.fareType) {
            FareType.FLAT -> handleFlatFare(player, system, station)
            else -> {
                activeJourneys[player.uniqueId] = JourneyData(
                    systemId = systemId,
                    startStation = stationId,
                    startLocation = player.location,
                    startTime = LocalDateTime.now()
                )
                activeTaps[player.uniqueId] = TapData(
                    systemId = systemId,
                    stationId = stationId,
                    timestamp = LocalDateTime.now()
                )
                player.sendMessage("§aTapped in at ${station.name}")
            }
        }
        return true
    }

    fun handleTapOut(player: Player, systemId: String, stationId: String): Boolean {
        val tapData = activeTaps[player.uniqueId] ?: return false
        val system = plugin.configManager.getTransitSystem(systemId) ?: return false
        
        val fare = calculateFare(tapData, stationId, system)
        if (chargeFare(player, fare)) {
            activeTaps.remove(player.uniqueId)
            activeJourneys.remove(player.uniqueId)
            
            // Log transaction
            plugin.transactionManager.logTransaction(
                Transaction(
                    playerId = player.uniqueId,
                    systemId = systemId,
                    fromStation = tapData.stationId,
                    toStation = stationId,
                    amount = fare,
                    type = TransactionType.EXIT
                )
            )
            
            player.sendMessage("§aFare charged: $${fare}")
            return true
        }
        return false
    }

    fun chargeMaximumFare(player: Player, system: TransitSystem) {
        val fare = system.maxFare
        if (chargeFare(player, fare)) {
            plugin.transactionManager.logTransaction(
                Transaction(
                    playerId = player.uniqueId,
                    systemId = system.id,
                    fromStation = "MAX_FARE_CHARGE",
                    toStation = null,
                    amount = fare,
                    type = TransactionType.FLAT_RATE
                )
            )
            player.sendMessage("§cMaximum fare charged: $${fare}")
        }
    }

    private fun handleFlatFare(player: Player, system: TransitSystem, station: Station) {
        val fare = system.fareData["fare"] as Double
        if (chargeFare(player, fare)) {
            plugin.transactionManager.logTransaction(
                Transaction(
                    playerId = player.uniqueId,
                    systemId = system.id,
                    fromStation = station.id,
                    toStation = null,
                    amount = fare,
                    type = TransactionType.FLAT_RATE
                )
            )
            player.sendMessage("§aFare charged: $${fare}")
        }
    }

    private fun calculateFare(tapData: TapData, exitStationId: String, system: TransitSystem): Double {
        val entryStation = plugin.stationManager.getStation(tapData.stationId)!!
        val exitStation = plugin.stationManager.getStation(exitStationId)!!

        return when (system.fareType) {
            FareType.ZONE -> zoneFareCalculator.calculateFare(entryStation.zone, exitStation.zone)
            FareType.DISTANCE -> {
                val distance = entryStation.location.distance(exitStation.location)
                val baseRate = system.fareData["baseRate"] as Double
                val perBlock = system.fareData["perBlock"] as Double
                minOf(baseRate + (distance * perBlock), system.maxFare)
            }
            FareType.FLAT -> system.fareData["fare"] as Double
        }.coerceAtMost(system.maxFare)
    }

    private fun chargeFare(player: Player, amount: Double): Boolean {
        return if (economy.has(player, amount)) {
            economy.withdrawPlayer(player, amount)
            true
        } else {
            player.sendMessage("§cInsufficient funds! Need: $$amount")
            false
        }
    }

    fun refundTransaction(transactionId: String): Boolean {
        val transaction = plugin.transactionManager.getTransaction(transactionId) ?: return false
        val player = plugin.server.getOfflinePlayer(transaction.playerId)
        
        economy.depositPlayer(player, transaction.amount)
        plugin.transactionManager.logTransaction(
            transaction.copy(
                id = UUID.randomUUID().toString(),
                type = TransactionType.REFUND,
                timestamp = LocalDateTime.now()
            )
        )
        return true
    }

    data class TapData(
        val systemId: String,
        val stationId: String,
        val timestamp: LocalDateTime
    )
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/GateManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.Gate
import com.example.transit.conversation.GateSetupConversation
import com.example.transit.util.toLocation
import com.example.transit.util.toStorableString
import org.bukkit.Location
import org.bukkit.block.Sign
import org.bukkit.entity.Player
import org.bukkit.configuration.file.YamlConfiguration
import java.io.File

class GateManager(private val plugin: TransitPlugin) {
    private val gates = mutableMapOf<String, Gate>()
    private val gatesFile = File(plugin.dataFolder, "gates.yml")
    private val config = YamlConfiguration.loadConfiguration(gatesFile)

    init {
        loadGates()
    }

    fun reload() {
        gates.clear()
        loadGates()
    }

    fun startGateCreation(player: Player, location: Location) {
        GateSetupConversation(plugin, location, player).start()
    }

    fun registerGate(gate: Gate) {
        gates[gate.id] = gate
        saveGate(gate)
        updateGateSign(gate)
    }

    fun removeGate(location: Location) {
        val gateId = getGateIdFromLocation(location)
        gates.remove(gateId)
        config.set(gateId, null)
        saveConfig()
    }

    fun removeGatesForStation(stationId: String) {
        val gatesToRemove = gates.values.filter { it.stationId == stationId }
        gatesToRemove.forEach { gate ->
            gates.remove(gate.id)
            config.set(gate.id, null)
        }
        saveConfig()
    }

    fun updateStationGates(stationId: String) {
        gates.values.filter { it.stationId == stationId }
            .forEach { updateGateSign(it) }
    }

    fun getGateAtLocation(location: Location): Gate? {
        val gateId = getGateIdFromLocation(location)
        return gates[gateId]
    }

    fun handleGateInteraction(player: Player, sign: Sign) {
        val gate = getGateAtLocation(sign.location) ?: return
        if (!gate.enabled) {
            player.sendMessage("§cThis gate is currently disabled!")
            return
        }

        val station = plugin.stationManager.getStation(gate.stationId) ?: return
        if (!station.status.isActive()) {
            player.sendMessage("§cThis station is currently closed!")
            return
        }

        val activeJourney = plugin.fareManager.getActiveJourney(player.uniqueId)
        if (activeJourney == null) {
            // Handle entry
            if (plugin.fareManager.handleTapIn(player, gate.systemId, gate.stationId)) {
                updateGateSign(gate)
                playGateEffect(gate, true)
            }
        } else {
            // Handle exit
            if (plugin.fareManager.handleTapOut(player, gate.systemId, gate.stationId)) {
                updateGateSign(gate)
                playGateEffect(gate, true)
            } else {
                playGateEffect(gate, false)
            }
        }
    }

    private fun loadGates() {
        for (gateId in config.getKeys(false)) {
            val section = config.getConfigurationSection(gateId) ?: continue
            try {
                gates[gateId] = Gate(
                    id = gateId,
                    location = section.getString("location")?.toLocation() ?: continue,
                    systemId = section.getString("systemId") ?: "",
                    stationId = section.getString("stationId") ?: "",
                    enabled = section.getBoolean("enabled", true)
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load gate $gateId: ${e.message}")
            }
        }
    }

    private fun saveGate(gate: Gate) {
        config.set("${gate.id}.location", gate.location.toStorableString())
        config.set("${gate.id}.systemId", gate.systemId)
        config.set("${gate.id}.stationId", gate.stationId)
        config.set("${gate.id}.enabled", gate.enabled)
        saveConfig()
    }

    private fun updateGateSign(gate: Gate) {
        val sign = gate.location.block.state as? Sign ?: return
        val station = plugin.stationManager.getStation(gate.stationId)

        sign.setLine(0, "§1[Fare]")
        sign.setLine(1, station?.name ?: "Unknown Station")
        sign.setLine(2, if (gate.enabled) "§aActive" else "§cDisabled")
        sign.setLine(3, station?.status?.name ?: "UNKNOWN")
        sign.update()
    }

    private fun getGateIdFromLocation(location: Location): String {
        return "${location.blockX}_${location.blockY}_${location.blockZ}"
    }

    private fun playGateEffect(gate: Gate, success: Boolean) {
        if (!plugin.config.getBoolean("gates.enableEffects", true)) return
        
        val location = gate.location
        // Play sound effect
        location.world?.playSound(
            location,
            if (success) org.bukkit.Sound.BLOCK_NOTE_BLOCK_PLING 
            else org.bukkit.Sound.BLOCK_NOTE_BLOCK_BASS,
            1f,
            if (success) 2f else 0.5f
        )

        // Show particles
        location.world?.spawnParticle(
            if (success) org.bukkit.Particle.VILLAGER_HAPPY 
            else org.bukkit.Particle.VILLAGER_ANGRY,
            location.add(0.5, 1.0, 0.5),
            5,
            0.2,
            0.2,
            0.2,
            0.0
        )
    }

    fun saveAll() {
        gates.values.forEach { saveGate(it) }
    }

    private fun saveConfig() {
        try {
            config.save(gatesFile)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save gates: ${e.message}")
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/RouteManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.Route
import org.bukkit.configuration.file.YamlConfiguration
import java.io.File

class RouteManager(private val plugin: TransitPlugin) {
    private val routes = mutableMapOf<String, Route>()
    private val routesFile: File
        get() = File(plugin.dataFolder, "routes.yml")
    private val config = YamlConfiguration.loadConfiguration(routesFile)

    init {
        loadRoutes()
    }

    fun reload() {
        routes.clear()
        loadRoutes()
    }

    private fun loadRoutes() {
        for (routeId in config.getKeys(false)) {
            val section = config.getConfigurationSection(routeId) ?: continue
            try {
                routes[routeId] = Route(
                    id = routeId,
                    name = section.getString("name") ?: continue,
                    systemId = section.getString("systemId") ?: continue,
                    stations = section.getStringList("stations").toMutableList()
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load route $routeId: ${e.message}")
            }
        }
    }

    fun addRoute(route: Route): Boolean {
        if (routes.containsKey(route.id)) return false
        routes[route.id] = route
        saveRoute(route)
        return true
    }

    fun removeRoute(routeId: String): Boolean {
        if (!routes.containsKey(routeId)) return false
        routes.remove(routeId)
        config.set(routeId, null)
        saveConfig()
        return true
    }

    fun getRoute(id: String): Route? = routes[id]

    fun getRoutes(): List<String> = routes.keys.toList()

    fun getSystems(): List<String> = routes.values.map { it.systemId }.distinct()

    fun getSystemRoutes(systemId: String): List<Route> =
        routes.values.filter { it.systemId == systemId }

    fun getStationRoutes(stationId: String): List<Route> =
        routes.values.filter { it.stations.contains(stationId) }

    fun getStationRoute(stationId: String): String? =
        routes.values.firstOrNull { it.stations.contains(stationId) }?.id

    fun addStationToRoute(routeId: String, stationId: String): Boolean {
        return routes[routeId]?.let { route ->
            if (!route.stations.contains(stationId)) {
                route.stations.add(stationId)
                saveRoute(route)
                true
            } else false
        } ?: false
    }

    fun removeStationFromRoute(routeId: String, stationId: String): Boolean {
        return routes[routeId]?.let { route ->
            if (route.stations.remove(stationId)) {
                saveRoute(route)
                true
            } else false
        } ?: false
    }

    fun reorderStations(routeId: String, newOrder: List<String>): Boolean {
        return routes[routeId]?.let { route ->
            if (route.stations.toSet() == newOrder.toSet()) {
                route.stations.clear()
                route.stations.addAll(newOrder)
                saveRoute(route)
                true
            } else false
        } ?: false
    }

    private fun saveRoute(route: Route) {
        config.set("${route.id}.name", route.name)
        config.set("${route.id}.systemId", route.systemId)
        config.set("${route.id}.stations", route.stations)
        saveConfig()
    }

    fun saveAll() {
        routes.values.forEach { saveRoute(it) }
    }

    private fun saveConfig() {
        try {
            config.save(routesFile)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save routes: ${e.message}")
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/StaffManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.*
import org.bukkit.configuration.file.YamlConfiguration
import org.bukkit.entity.Player
import java.io.File
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit
import java.util.*
import java.util.concurrent.ConcurrentHashMap

class StaffManager(private val plugin: TransitPlugin) {
    private val staffMembers = ConcurrentHashMap<String, MutableSet<StaffMember>>()
    private val staffPerformance = ConcurrentHashMap<UUID, StaffPerformance>()
    private val activeShifts = ConcurrentHashMap<UUID, StaffShift>()
    private val pendingPayments = ConcurrentHashMap<UUID, MutableList<PendingPayment>>()
    private val staffFile = File(plugin.dataFolder, "staff.yml")
    private val config = YamlConfiguration.loadConfiguration(staffFile)

    init {
        loadStaffData()
        startPaymentScheduler()
        startPerformanceTracker()
    }

    fun reload() {
        staffMembers.clear()
        loadStaffData()
    }

    fun addStaffMember(
        playerId: UUID,
        systemId: String,
        role: StaffRole,
        salary: Double,
        period: PaymentPeriod = PaymentPeriod.MONTHLY
    ): Boolean {
        if (isStaff(playerId, systemId)) return false

        val staffMember = StaffMember(
            playerId = playerId,
            systemId = systemId,
            role = role,
            salary = salary,
            paymentPeriod = period,
            lastPaid = LocalDateTime.now(),
            hireDate = LocalDateTime.now()
        )
        
        staffMembers.getOrPut(systemId) { mutableSetOf() }.add(staffMember)
        initializePerformance(playerId)
        saveStaffMember(staffMember)
        return true
    }

    fun removeStaffMember(playerId: UUID, systemId: String): Boolean {
        return staffMembers[systemId]?.let { members ->
            val removed = members.removeIf { it.playerId == playerId }
            if (removed) {
                saveStaffData()
                staffPerformance.remove(playerId)
            }
            removed
        } ?: false
    }

    fun updateStaffRole(playerId: UUID, systemId: String, newRole: StaffRole): Boolean {
        return staffMembers[systemId]?.find { it.playerId == playerId }?.let { member ->
            val updatedMember = member.copy(role = newRole)
            staffMembers[systemId]?.remove(member)
            staffMembers[systemId]?.add(updatedMember)
            saveStaffMember(updatedMember)
            true
        } ?: false
    }

    fun updateSalary(playerId: UUID, systemId: String, newSalary: Double): Boolean {
        return staffMembers[systemId]?.find { it.playerId == playerId }?.let { member ->
            val updatedMember = member.copy(salary = newSalary)
            staffMembers[systemId]?.remove(member)
            staffMembers[systemId]?.add(updatedMember)
            saveStaffMember(updatedMember)
            true
        } ?: false
    }

    fun startShift(playerId: UUID, systemId: String): Boolean {
        if (!isStaff(playerId, systemId)) return false
        if (activeShifts.containsKey(playerId)) return false

        val shift = StaffShift(
            startTime = LocalDateTime.now(),
            systemId = systemId,
            staffId = playerId
        )
        activeShifts[playerId] = shift
        staffPerformance[playerId]?.shiftHistory?.add(shift)
        return true
    }

    fun endShift(playerId: UUID): Boolean {
        val shift = activeShifts.remove(playerId) ?: return false
        shift.endTime = LocalDateTime.now()
        calculateShiftPay(playerId, shift)
        return true
    }

    fun isStaff(playerId: UUID, systemId: String): Boolean {
        return staffMembers[systemId]?.any { it.playerId == playerId } ?: false
    }

    fun isStaffAnywhere(playerId: UUID): Boolean {
        return staffMembers.values.any { members -> 
            members.any { it.playerId == playerId }
        }
    }

    fun hasPermission(playerId: UUID, systemId: String, permission: StaffPermission): Boolean {
        return staffMembers[systemId]?.find { it.playerId == playerId }?.let { member ->
            member.role.permissions.contains(permission)
        } ?: false
    }

    fun getSystemStaff(systemId: String): Set<StaffMember> {
        return staffMembers[systemId]?.toSet() ?: emptySet()
    }

    fun getStaffPerformance(playerId: UUID): StaffPerformance? {
        return staffPerformance[playerId]
    }

    fun checkPendingPayments(player: Player) {
        pendingPayments[player.uniqueId]?.let { payments ->
            payments.forEach { payment ->
                if (processPayment(player, payment)) {
                    payments.remove(payment)
                }
            }
        }
    }

    private fun processPayment(player: Player, payment: PendingPayment): Boolean {
        val systemBalance = plugin.transactionManager.getSystemBalance(payment.systemId)
        if (systemBalance < payment.amount) return false

        if (plugin.economy.depositPlayer(player, payment.amount).transactionSuccess()) {
            plugin.transactionManager.logTransaction(
                Transaction(
                    playerId = payment.playerId,
                    systemId = payment.systemId,
                    fromStation = "STAFF_PAYMENT",
                    toStation = null,
                    amount = payment.amount,
                    type = TransactionType.STAFF_PAYMENT
                )
            )
            return true
        }
        return false
    }

    private fun startPaymentScheduler() {
        plugin.server.scheduler.runTaskTimer(plugin, Runnable {
            processPayments()
        }, 72000L, 72000L) // Every hour
    }

    private fun startPerformanceTracker() {
        plugin.server.scheduler.runTaskTimer(plugin, Runnable {
            updateAllPerformanceMetrics()
        }, 36000L, 36000L) // Every 30 minutes
    }

    private fun loadStaffData() {
        if (!config.contains("staff")) return
        
        config.getConfigurationSection("staff")?.getKeys(false)?.forEach { systemId ->
            val members = mutableSetOf<StaffMember>()
            config.getConfigurationSection("staff.$systemId")?.getKeys(false)?.forEach { playerIdStr ->
                val section = config.getConfigurationSection("staff.$systemId.$playerIdStr")
                section?.let {
                    members.add(
                        StaffMember(
                            playerId = UUID.fromString(playerIdStr),
                            systemId = systemId,
                            role = StaffRole.valueOf(it.getString("role", "TRAINEE")!!),
                            salary = it.getDouble("salary"),
                            paymentPeriod = PaymentPeriod.valueOf(it.getString("period", "MONTHLY")!!),
                            lastPaid = LocalDateTime.parse(it.getString("lastPaid") 
                                ?: LocalDateTime.now().toString()),
                            hireDate = LocalDateTime.parse(it.getString("hireDate") 
                                ?: LocalDateTime.now().toString())
                        )
                    )
                }
            }
            staffMembers[systemId] = members
        }
    }

    private fun saveStaffData() {
        config.set("staff", null) // Clear existing data
        staffMembers.entries.forEach { (systemId, members) ->
            members.forEach { staffMember ->
            saveStaffMember(staffMember)
            }
        }
        saveConfig()
    }

    private fun saveStaffMember(staffMember: StaffMember) {
        val path = "staff.${staffMember.systemId}.${staffMember.playerId}"
        config.set("$path.role", staffMember.role.name)
        config.set("$path.salary", staffMember.salary)
        config.set("$path.period", staffMember.paymentPeriod.name)
        config.set("$path.lastPaid", staffMember.lastPaid.toString())
        config.set("$path.hireDate", staffMember.hireDate.toString())
        saveConfig()
    }

    private fun saveConfig() {
        try {
            config.save(staffFile)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save staff data: ${e.message}")
        }
    }

    private data class PendingPayment(
        val playerId: UUID,
        val systemId: String,
        val amount: Double,
        val type: PaymentType,
        val timestamp: LocalDateTime = LocalDateTime.now()
    )

    private enum class PaymentType {
        REGULAR_SALARY,
        SHIFT_PAY,
        PERFORMANCE_BONUS
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/StationManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.Station
import com.example.transit.model.StationStatus
import com.example.transit.util.toLocation
import com.example.transit.util.toStorableString
import org.bukkit.configuration.file.YamlConfiguration
import java.io.File

class StationManager(private val plugin: TransitPlugin) {
    private val stations = mutableMapOf<String, Station>()
    private val stationsFile = File(plugin.dataFolder, "stations.yml")
    private val config = YamlConfiguration.loadConfiguration(stationsFile)

    init {
        loadStations()
    }

    fun addStation(station: Station): Boolean {
        if (stations.containsKey(station.id)) return false
        stations[station.id] = station
        saveStation(station)
        return true
    }

    fun removeStation(id: String): Boolean {
        if (!stations.containsKey(id)) return false
        
        // Check if station is used in any routes
        val routes = plugin.routeManager.getStationRoutes(id)
        if (routes.isNotEmpty()) {
            routes.forEach { route ->
                plugin.routeManager.removeStationFromRoute(route.id, id)
            }
        }

        // Remove any gates at this station
        stations[id]?.let { station ->
            plugin.gateManager.removeGatesForStation(station.id)
        }

        stations.remove(id)
        config.set(id, null)
        saveConfig()
        return true
    }

    fun getStation(id: String): Station? = stations[id]

    fun getAllStations(): List<Station> = stations.values.toList()

    fun getSystemStations(systemId: String): List<Station> =
        stations.values.filter { it.systemId == systemId }

    fun getStationsByZone(systemId: String, zone: String): List<Station> =
        stations.values.filter { it.systemId == systemId && it.zone == zone }

    fun getNearbyStations(location: org.bukkit.Location, radius: Double): List<Station> =
        stations.values.filter {
            it.location.world?.name == location.world?.name &&
            it.location.distance(location) <= radius
        }

    fun updateStationStatus(stationId: String, status: StationStatus): Boolean {
        return stations[stationId]?.let { station ->
            station.status = status
            // Update any gates at this station
            plugin.gateManager.updateStationGates(stationId)
            saveStation(station)
            true
        } ?: false
    }

    fun updateStationZone(stationId: String, newZone: String): Boolean {
        return stations[stationId]?.let { station ->
            val updatedStation = station.copy(zone = newZone)
            stations[stationId] = updatedStation
            saveStation(updatedStation)
            true
        } ?: false
    }

    fun relocateStation(stationId: String, newLocation: org.bukkit.Location): Boolean {
        return stations[stationId]?.let { station ->
            val updatedStation = station.copy(location = newLocation)
            stations[stationId] = updatedStation
            saveStation(updatedStation)
            true
        } ?: false
    }

    private fun loadStations() {
        for (stationId in config.getKeys(false)) {
            val section = config.getConfigurationSection(stationId) ?: continue
            try {
                stations[stationId] = Station(
                    id = stationId,
                    name = section.getString("name") ?: "",
                    systemId = section.getString("systemId") ?: "",
                    location = section.getString("location")?.toLocation() ?: continue,
                    zone = section.getString("zone") ?: "1",
                    status = StationStatus.valueOf(section.getString("status") ?: "ACTIVE")
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load station $stationId: ${e.message}")
            }
        }
    }

    private fun saveStation(station: Station) {
        config.set("${station.id}.name", station.name)
        config.set("${station.id}.systemId", station.systemId)
        config.set("${station.id}.location", station.location.toStorableString())
        config.set("${station.id}.zone", station.zone)
        config.set("${station.id}.status", station.status.name)
        saveConfig()
    }

    fun saveAll() {
        stations.values.forEach { saveStation(it) }
    }

    private fun saveConfig() {
        try {
            config.save(stationsFile)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save stations: ${e.message}")
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/StatisticsManager.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import com.example.transit.statistics.StatisticsManager.StatisticsPeriod
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException

class StatisticsCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    
    private val dateFormat = DateTimeFormatter.ofPattern("yyyy-MM-dd")

    override fun onCommand(
        sender: CommandSender,
        command: Command,
        label: String,
        args: Array<out String>
    ): Boolean {
        if (!sender.hasPermission("transit.stats")) {
            sender.sendMessage("§cYou don't have permission to view statistics!")
            return true
        }

        if (args.isEmpty()) {
            sendHelp(sender)
            return true
        }

        when (args[0].toLowerCase()) {
            "system" -> handleSystemStats(sender, args)
            "station" -> handleStationStats(sender, args)
            "route" -> handleRouteStats(sender, args)
            "report" -> handleReport(sender, args)
            "peaks" -> handlePeakTimes(sender, args)
            "export" -> handleExport(sender, args)
            else -> sendHelp(sender)
        }
        return true
    }

    private fun handleSystemStats(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /stats system <systemId> [period]")
            return
        }

        val systemId = args[1]
        val period = if (args.size > 2) {
            try {
                StatisticsPeriod.valueOf(args[2].uppercase())
            } catch (e: IllegalArgumentException) {
                StatisticsPeriod.ALL_TIME
            }
        } else StatisticsPeriod.ALL_TIME

        val stats = plugin.statisticsManager.getSystemStatistics(systemId, period)
        if (stats == null) {
            sender.sendMessage("§cNo statistics found for system $systemId")
            return
        }

        sender.sendMessage("""
            §6System Statistics - $systemId ($period)
            §7Revenue: §f$${stats.totalRevenue}
            §7Transactions: §f${stats.totalTransactions}
            §7Average Fare: §f$${stats.averageFare}
            §7Entry Count: §f${stats.entryCount}
            §7Exit Count: §f${stats.exitCount}
            §7Direct Fares: §f${stats.directFares}
            §7Last Updated: §f${stats.lastUpdated}
            
            §6Hourly Breakdown:
            ${formatHourlyStats(stats.hourlyStats)}
        """.trimIndent())
    }

    private fun handleStationStats(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /stats station <stationId> [period]")
            return
        }

        val stationId = args[1]
        val period = if (args.size > 2) {
            try {
                StatisticsPeriod.valueOf(args[2].uppercase())
            } catch (e: IllegalArgumentException) {
                StatisticsPeriod.ALL_TIME
            }
        } else StatisticsPeriod.ALL_TIME

        val stats = plugin.statisticsManager.getStationStatistics(stationId, period)
        if (stats == null) {
            sender.sendMessage("§cNo statistics found for station $stationId")
            return
        }

        val station = plugin.stationManager.getStation(stationId)
        sender.sendMessage("""
            §6Station Statistics - ${station?.name ?: stationId} ($period)
            §7Revenue: §f$${stats.totalRevenue}
            §7Transactions: §f${stats.totalTransactions}
            §7Average Fare: §f$${stats.averageFare}
            §7Entry Count: §f${stats.entryCount}
            §7Exit Count: §f${stats.exitCount}
            §7Last Updated: §f${stats.lastUpdated}
            
            §6Hourly Usage:
            ${formatHourlyStats(stats.hourlyStats)}
        """.trimIndent())
    }

    private fun handleRouteStats(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /stats route <routeId> [period]")
            return
        }

        val routeId = args[1]
        val period = if (args.size > 2) {
            try {
                StatisticsPeriod.valueOf(args[2].uppercase())
            } catch (e: IllegalArgumentException) {
                StatisticsPeriod.ALL_TIME
            }
        } else StatisticsPeriod.ALL_TIME

        val stats = plugin.statisticsManager.getRouteStatistics(routeId, period)
        if (stats == null) {
            sender.sendMessage("§cNo statistics found for route $routeId")
            return
        }

        val route = plugin.routeManager.getRoute(routeId)
        sender.sendMessage("""
            §6Route Statistics - ${route?.name ?: routeId} ($period)
            §7Revenue: §f$${stats.totalRevenue}
            §7Transactions: §f${stats.totalTransactions}
            §7Average Fare: §f$${stats.averageFare}
            §7Last Updated: §f${stats.lastUpdated}
            
            §6Hourly Usage:
            ${formatHourlyStats(stats.hourlyStats)}
        """.trimIndent())
    }

    private fun handleReport(sender: CommandSender, args: Array<out String>) {
        if (args.size < 4) {
            sender.sendMessage("§cUsage: /stats report <systemId> <startDate> <endDate>")
            sender.sendMessage("§cDate format: YYYY-MM-DD")
            return
        }

        val systemId = args[1]
        val startDate = try {
            LocalDate.parse(args[2], dateFormat)
        } catch (e: DateTimeParseException) {
            sender.sendMessage("§cInvalid start date format. Use YYYY-MM-DD")
            return
        }

        val endDate = try {
            LocalDate.parse(args[3], dateFormat)
        } catch (e: DateTimeParseException) {
            sender.sendMessage("§cInvalid end date format. Use YYYY-MM-DD")
            return
        }

        val report = plugin.statisticsManager.generateReport(systemId, startDate, endDate)
        
        sender.sendMessage("""
            §6System Report - $systemId
            §7Period: §f${report.period.startDate} to ${report.period.endDate}
            
            §6Overall Statistics:
            §7Total Revenue: §f$${report.totalRevenue}
            §7Total Transactions: §f${report.totalTransactions}
            §7Average Transaction: §f$${report.averageTransactionValue}
            
            §6Peak Hours:
            ${report.peakHours.joinToString("\n") { 
                "§7${it.hour}:00 - ${it.hour + 1}:00: §f${it.transactions} transactions"
            }}
            
            §6Busiest Stations:
            ${report.busyStations.take(5).joinToString("\n") { 
                "§7${it.name}: §f${it.usageCount} uses"
            }}
            
            §6Popular Routes:
            ${report.popularRoutes.take(5).joinToString("\n") { 
                "§7${formatRoute(it)}: §f${it.usageCount} trips (avg: $${it.averageFare})"
            }}
        """.trimIndent())
    }

    private fun handlePeakTimes(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /stats peaks <systemId>")
            return
        }

        val systemId = args[1]
        val peakHours = plugin.statisticsManager.getPeakHours(systemId)
        
        if (peakHours.isEmpty()) {
            sender.sendMessage("§cNo peak time data available for system $systemId")
            return
        }

        sender.sendMessage("§6Peak Hours for $systemId:")
        peakHours.forEach { peak ->
            sender.sendMessage("§7${peak.hour}:00 - ${peak.hour + 1}:00: §f${peak.transactions} transactions")
        }
    }

    private fun handleExport(sender: CommandSender, args: Array<out String>) {
        if (args.size < 3) {
            sender.sendMessage("§cUsage: /stats export <systemId> <type>")
            sender.sendMessage("§cTypes: csv, json")
            return
        }

        sender.sendMessage("§cExport functionality not yet implemented")
        // TODO: Implement export functionality
    }

    private fun formatHourlyStats(stats: Map<Int, Int>): String {
        return stats.entries
            .sortedBy { it.key }
            .joinToString("\n") { (hour, count) ->
                "§7${hour}:00 - ${hour + 1}:00: §f$count"
            }
    }

    private fun formatRoute(route: StatisticsManager.PopularRoute): String {
        val fromStation = plugin.stationManager.getStation(route.fromStationId)?.name ?: route.fromStationId
        val toStation = plugin.stationManager.getStation(route.toStationId)?.name ?: route.toStationId
        return "$fromStation → $toStation"
    }

    override fun onTabComplete(
        sender: CommandSender,
        command: Command,
        alias: String,
        args: Array<out String>
    ): List<String> {
        return when (args.size) {
            1 -> listOf("system", "station", "route", "report", "peaks", "export")
                .filter { it.startsWith(args[0].toLowerCase()) }
            2 -> when (args[0].toLowerCase()) {
                "system", "report", "peaks" -> plugin.configManager.getSystems().map { it.id }
                "station" -> plugin.stationManager.getAllStations().map { it.id }
                "route" -> plugin.routeManager.getRoutes()
                "export" -> plugin.configManager.getSystems().map { it.id }
                else -> emptyList()
            }.filter { it.startsWith(args[1].toLowerCase()) }
            3 -> when (args[0].toLowerCase()) {
                "system", "station", "route" -> 
                    StatisticsPeriod.values().map { it.name.toLowerCase() }
                "export" -> listOf("csv", "json")
                else -> emptyList()
            }.filter { it.startsWith(args[2].toLowerCase()) }
            else -> emptyList()
        }
    }

    private fun sendHelp(sender: CommandSender) {
        sender.sendMessage("""
            §6Statistics Commands:
            §f/stats system <systemId> [period] - View system statistics
            §f/stats station <stationId> [period] - View station statistics
            §f/stats route <routeId> [period] - View route statistics
            §f/stats report <systemId> <startDate> <endDate> - Generate detailed report
            §f/stats peaks <systemId> - View peak usage times
            §f/stats export <systemId> <type> - Export statistics
            
            §7Periods: daily, weekly, monthly, all_time
        """.trimIndent())
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/TransactionManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.Transaction
import com.example.transit.model.TransactionType
import org.bukkit.configuration.file.YamlConfiguration
import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*
import java.util.concurrent.ConcurrentHashMap

class TransactionManager(private val plugin: TransitPlugin) {
    private val transactions = ConcurrentHashMap<String, Transaction>()
    private val systemBalances = ConcurrentHashMap<String, Double>()
    private val dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM")
    
    fun logTransaction(transaction: Transaction) {
        transactions[transaction.id] = transaction
        updateSystemBalance(transaction)
        saveTransaction(transaction)
        updateStatistics(transaction)
    }

    fun getTransaction(id: String): Transaction? = transactions[id]

    fun getSystemBalance(systemId: String): Double = systemBalances.getOrDefault(systemId, 0.0)

    fun getTransactionsBySystem(systemId: String): List<Transaction> =
        transactions.values.filter { it.systemId == systemId }

    fun getTransactionsByPlayer(playerId: UUID): List<Transaction> =
        transactions.values.filter { it.playerId == playerId }

    private fun updateSystemBalance(transaction: Transaction) {
        when (transaction.type) {
            TransactionType.ENTRY, TransactionType.EXIT, TransactionType.FLAT_RATE -> {
                systemBalances.merge(transaction.systemId, transaction.amount, Double::plus)
            }
            TransactionType.REFUND, TransactionType.STAFF_PAYMENT -> {
                systemBalances.merge(transaction.systemId, -transaction.amount, Double::plus)
            }
            else -> {} // Handle other transaction types
        }
    }

    private fun saveTransaction(transaction: Transaction) {
        val month = transaction.timestamp.format(dateFormatter)
        val file = getTransactionFile(month)
        val config = YamlConfiguration.loadConfiguration(file)

        config.set("${transaction.id}.playerId", transaction.playerId.toString())
        config.set("${transaction.id}.systemId", transaction.systemId)
        config.set("${transaction.id}.fromStation", transaction.fromStation)
        config.set("${transaction.id}.toStation", transaction.toStation)
        config.set("${transaction.id}.amount", transaction.amount)
        config.set("${transaction.id}.type", transaction.type.name)
        config.set("${transaction.id}.timestamp", transaction.timestamp.toString())

        try {
            config.save(file)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save transaction ${transaction.id}: ${e.message}")
        }
    }

    private fun getTransactionFile(month: String): File {
        val folder = File(plugin.dataFolder, "transactions")
        if (!folder.exists()) folder.mkdirs()
        return File(folder, "$month.yml")
    }

    private fun updateStatistics(transaction: Transaction) {
        plugin.statisticsManager.updateStatistics(transaction)
    }

    fun saveAll() {
        transactions.values.forEach { saveTransaction(it) }
        saveSystemBalances()
    }

    private fun saveSystemBalances() {
        val file = File(plugin.dataFolder, "balances.yml")
        val config = YamlConfiguration.loadConfiguration(file)

        systemBalances.forEach { (systemId, balance) ->
            config.set("balances.$systemId", balance)
        }

        try {
            config.save(file)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save system balances: ${e.message}")
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/model/FareRule.kt">
package com.example.transit.fare

import org.bukkit.configuration.ConfigurationSection

class FareRule(config: ConfigurationSection) {
    val fromPattern: String? = config.getString("from")
    val toPattern: String? = config.getString("to")
    val fare: Double = config.getDouble("fare")
    val ringDifference: Int? = if (config.contains("ringDifference")) config.getInt("ringDifference") else null
    val fromGroup: String? = config.getString("fromGroup")
    val toGroup: String? = config.getString("toGroup")
    val crossGroup: Boolean = config.getBoolean("crossGroup", false)

    fun matches(fromZone: String, toZone: String): Boolean {
        // Check exact zone patterns if specified
        if (fromPattern != null && toPattern != null) {
            val fromMatches = fromZone.matches(fromPattern.toRegex())
            val toMatches = toZone.matches(toPattern.toRegex())
            if (fromMatches && toMatches) return true
        }
        
        // Check group matching if specified
        if (fromGroup != null && toGroup != null) {
            return matchesGroups(fromZone, toZone)
        }
        
        return false
    }

    fun matchesRingDifference(difference: Int): Boolean {
        return ringDifference != null && ringDifference == difference
    }
    
    private fun matchesGroups(fromZone: String, toZone: String): Boolean {
        // This should be implemented based on your zone group configuration
        // For now, return false as we need the zone group configuration
        return false
    }
    
    override fun toString(): String {
        return "FareRule(from=$fromPattern, to=$toPattern, fare=$fare, ringDiff=$ringDifference)"
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/model/JourneyData.kt">
package com.example.transit.model

import org.bukkit.Location
import java.time.LocalDateTime

data class JourneyData(
    val systemId: String,
    val startStation: String,
    val startLocation: Location,
    val startTime: LocalDateTime = LocalDateTime.now()
)
</file>

<file path="src/main/kotlin/com/example/transit/model/Models.kt">
// src/main/kotlin/com/example/transit/model/Models.kt
package com.example.transit.model

import org.bukkit.Location
import java.time.LocalDateTime
import java.util.UUID

// Enums
enum class FareType {
    ZONE,
    FLAT,
    DISTANCE
}

enum class PaymentPeriod {
    DAILY,
    WEEKLY,
    MONTHLY
}

enum class StationStatus {
    ACTIVE,
    DISABLED,
    MAINTENANCE;

    fun isActive(): Boolean = this == ACTIVE
}

// Data Classes
data class Station(
    val id: String,
    val name: String,
    val systemId: String,
    val location: Location,
    val zone: String,
    var status: StationStatus = StationStatus.ACTIVE
)

data class Route(
    val id: String,
    val name: String,
    val systemId: String,
    val stations: MutableList<String> = mutableListOf()
)

data class TransitSystem(
    val id: String,
    val name: String,
    val fareType: FareType,
    val fareData: Map<String, Any>,
    val maxFare: Double
)

data class Transaction(
    val id: String = UUID.randomUUID().toString(),
    val playerId: UUID,
    val systemId: String,
    val fromStation: String,
    val toStation: String?,
    val amount: Double,
    val type: TransactionType,
    val timestamp: LocalDateTime = LocalDateTime.now()
)

data class Gate(
    val id: String,
    val location: Location,
    val systemId: String,
    val stationId: String,
    var enabled: Boolean = true
)

data class ZoneGroup(
    val name: String,
    val zones: Set<String>
)
</file>

<file path="src/main/kotlin/com/example/transit/model/StaffModels.kt">
// src/main/kotlin/com/example/transit/model/StaffModels.kt
package com.example.transit.model

import java.time.LocalDateTime
import java.util.UUID

enum class StaffRole(val permissions: Set<StaffPermission>) {
    SUPERVISOR(setOf(
        StaffPermission.MANAGE_GATES,
        StaffPermission.MANAGE_FARES,
        StaffPermission.VIEW_STATISTICS,
        StaffPermission.MANAGE_STAFF,
        StaffPermission.OVERRIDE_GATES,
        StaffPermission.REFUND_TRANSACTIONS
    )),
    OPERATOR(setOf(
        StaffPermission.VIEW_STATISTICS,
        StaffPermission.OVERRIDE_GATES
    )),
    TRAINEE(setOf(
        StaffPermission.VIEW_STATISTICS
    ))
}

enum class StaffPermission {
    MANAGE_GATES,
    MANAGE_FARES,
    VIEW_STATISTICS,
    MANAGE_STAFF,
    OVERRIDE_GATES,
    REFUND_TRANSACTIONS
}

data class StaffMember(
    val playerId: UUID,
    val systemId: String,
    val role: StaffRole,
    val salary: Double,
    val paymentPeriod: PaymentPeriod,
    val lastPaid: LocalDateTime = LocalDateTime.now(),
    val hireDate: LocalDateTime = LocalDateTime.now()
)

data class StaffPerformance(
    val playerId: UUID,
    val shiftHistory: MutableList<StaffShift>,
    var transactions: Int = 0,
    var customerInteractions: Int = 0,
    var incidentCount: Int = 0,
    var averageResponseTime: Double = 0.0,
    var lastEvaluation: LocalDateTime = LocalDateTime.now()
) {
    fun calculateBonus(): Double {
        var bonus = 0.0
        if (transactions > 1000) bonus += 100.0
        if (transactions > 2000) bonus += 200.0
        if (averageResponseTime < 30.0) bonus += 100.0
        bonus += customerInteractions * 0.5
        return bonus
    }
}

data class StaffShift(
    val startTime: LocalDateTime,
    val systemId: String,
    val staffId: UUID,
    var endTime: LocalDateTime? = null,
    var transactions: Int = 0,
    var incidents: Int = 0,
    private val incidentLog: MutableList<ShiftIncident> = mutableListOf()
) {
    fun addIncident(severity: IncidentSeverity) {
        incidentLog.add(ShiftIncident(severity, LocalDateTime.now()))
    }

    fun getIncidents(): List<ShiftIncident> = incidentLog.toList()
}

data class ShiftIncident(
    val severity: IncidentSeverity,
    val timestamp: LocalDateTime
)

enum class IncidentSeverity {
    LOW,
    MEDIUM,
    HIGH,
    CRITICAL
}
</file>

<file path="src/main/kotlin/com/example/transit/model/TransactionType.kt">
package com.example.transit.model

enum class TransactionType {
    ENTRY,
    EXIT,
    INTERCHANGE_ENTRY,
    INTERCHANGE_EXIT,
    FLAT_RATE,
    REFUND,
    STAFF_PAYMENT
}
</file>

<file path="src/main/kotlin/com/example/transit/statistics/StatisticsManager.kt">
// src/main/kotlin/com/example/transit/statistics/StatisticsManager.kt
package com.example.transit.statistics

import com.example.transit.TransitPlugin
import com.example.transit.model.Station
import com.example.transit.model.Transaction
import java.time.LocalDate
import java.time.LocalDateTime
import org.bukkit.configuration.file.YamlConfiguration
import java.io.File

class StatisticsManager(private val plugin: TransitPlugin) {

    private val statisticsCache = mutableMapOf<String, Statistics>()
    private val statisticsFile = File(plugin.dataFolder, "statistics.yml")
    private val config = YamlConfiguration.loadConfiguration(statisticsFile)

    fun reload() {
        statisticsCache.clear()
        loadStatistics()
    }

    fun saveAll() {
        statisticsCache.forEach { (id, stats) -> saveStatistics(id, stats) }
    }

    fun getSystemStatistics(systemId: String, period: StatisticsPeriod = StatisticsPeriod.ALL_TIME): Statistics? {
        return statisticsCache["system_$systemId"]
    }

    fun getStationStatistics(stationId: String, period: StatisticsPeriod = StatisticsPeriod.ALL_TIME): Statistics? {
        return statisticsCache["station_$stationId"]
    }

    fun getRouteStatistics(routeId: String, period: StatisticsPeriod = StatisticsPeriod.ALL_TIME): Statistics? {
        return statisticsCache["route_$routeId"]
    }

    fun updateStatistics(transaction: Transaction) {
        // Update system statistics
        updateEntityStatistics("system_${transaction.systemId}", transaction)
        
        // Update station statistics
        updateEntityStatistics("station_${transaction.fromStation}", transaction)
        if (transaction.toStation != null) {
            updateEntityStatistics("station_${transaction.toStation}", transaction)
        }
    }

    fun generateReport(systemId: String, startDate: LocalDate, endDate: LocalDate): Report {
        // Implementation for generating reports
        return Report(
            period = ReportPeriod(startDate, endDate),
            totalRevenue = 0.0,
            totalTransactions = 0,
            averageTransactionValue = 0.0,
            peakHours = listOf(),
            busyStations = listOf(),
            popularRoutes = listOf()
        )
    }

    fun getPeakHours(systemId: String): List<PeakHour> {
        return statisticsCache["system_$systemId"]?.hourlyStats?.map { 
            PeakHour(it.key, it.value)
        }?.sortedByDescending { it.transactions } ?: listOf()
    }

    private fun updateEntityStatistics(entityId: String, transaction: Transaction) {
        val stats = statisticsCache.getOrPut(entityId) { Statistics() }
        stats.apply {
            totalRevenue += transaction.amount
            totalTransactions++
            lastUpdated = LocalDateTime.now()
            
            val hour = transaction.timestamp.hour
            hourlyStats[hour] = hourlyStats.getOrDefault(hour, 0) + 1
        }
        saveStatistics(entityId, stats)
    }

    private fun loadStatistics() {
        for (entityId in config.getKeys(false)) {
            val section = config.getConfigurationSection(entityId) ?: continue
            try {
                statisticsCache[entityId] = Statistics(
                    totalRevenue = section.getDouble("totalRevenue"),
                    totalTransactions = section.getInt("totalTransactions"),
                    entryCount = section.getInt("entryCount"),
                    exitCount = section.getInt("exitCount"),
                    directFares = section.getInt("directFares"),
                    lastUpdated = LocalDateTime.parse(section.getString("lastUpdated") 
                        ?: LocalDateTime.now().toString()),
                    hourlyStats = section.getConfigurationSection("hourlyStats")?.let { hourlySection ->
                        hourlySection.getKeys(false).associate {
                            it.toInt() to hourlySection.getInt(it)
                        }
                    } ?: mutableMapOf()
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load statistics for $entityId: ${e.message}")
            }
        }
    }

    private fun saveStatistics(entityId: String, stats: Statistics) {
        config.set("$entityId.totalRevenue", stats.totalRevenue)
        config.set("$entityId.totalTransactions", stats.totalTransactions)
        config.set("$entityId.entryCount", stats.entryCount)
        config.set("$entityId.exitCount", stats.exitCount)
        config.set("$entityId.directFares", stats.directFares)
        config.set("$entityId.lastUpdated", stats.lastUpdated.toString())
        
        stats.hourlyStats.forEach { (hour, count) ->
            config.set("$entityId.hourlyStats.$hour", count)
        }
        
        try {
            config.save(statisticsFile)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save statistics: ${e.message}")
        }
    }

    data class Statistics(
        var totalRevenue: Double = 0.0,
        var totalTransactions: Int = 0,
        var entryCount: Int = 0,
        var exitCount: Int = 0,
        var directFares: Int = 0,
        var lastUpdated: LocalDateTime = LocalDateTime.now(),
        var hourlyStats: MutableMap<Int, Int> = mutableMapOf()
    ) {
        val averageFare: Double
            get() = if (totalTransactions > 0) totalRevenue / totalTransactions else 0.0
    }

    data class Report(
        val period: ReportPeriod,
        val totalRevenue: Double,
        val totalTransactions: Int,
        val averageTransactionValue: Double,
        val peakHours: List<PeakHour>,
        val busyStations: List<BusyStation>,
        val popularRoutes: List<PopularRoute>
    )

    data class ReportPeriod(
        val startDate: LocalDate,
        val endDate: LocalDate
    )

    data class PeakHour(
        val hour: Int,
        val transactions: Int
    )

    data class BusyStation(
        val name: String,
        val usageCount: Int
    )

    data class PopularRoute(
        val fromStationId: String,
        val toStationId: String,
        val usageCount: Int,
        val averageFare: Double
    )

    enum class StatisticsPeriod {
        DAILY,
        WEEKLY,
        MONTHLY,
        ALL_TIME
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/util/Extensions.kt">
package com.example.transit.util

import org.bukkit.Bukkit
import org.bukkit.Location
import org.bukkit.configuration.ConfigurationSection
import java.text.DecimalFormat
import kotlin.math.roundToInt

fun Location.toStorableString(): String {
    return "${world?.name},${x},${y},${z},${yaw},${pitch}"
}

fun String.toLocation(): Location? {
    val parts = split(",")
    if (parts.size != 6) return null
    
    return try {
        Location(
            Bukkit.getWorld(parts[0]),
            parts[1].toDouble(),
            parts[2].toDouble(),
            parts[3].toDouble(),
            parts[4].toFloat(),
            parts[5].toFloat()
        )
    } catch (e: Exception) {
        null
    }
}

fun ConfigurationSection.getLocationList(path: String): List<Location> {
    return getStringList(path).mapNotNull { it.toLocation() }
}

fun Double.roundToDecimals(decimals: Int): Double {
    val factor = 10.0.pow(decimals)
    return (this * factor).roundToInt() / factor
}

fun Double.formatCurrency(): String {
    return DecimalFormat("$#,##0.00").format(this)
}

private fun Double.pow(n: Int): Double = Math.pow(this, n.toDouble())

fun String.sanitizeFileName(): String {
    return this.replace(Regex("[^a-zA-Z0-9.-]"), "_")
}

fun Location.distanceTo(other: Location): Double {
    return if (world?.name == other.world?.name) {
        distance(other)
    } else {
        Double.POSITIVE_INFINITY
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/TransitPlugin.kt">
package com.example.transit

import com.example.transit.api.TransitAPI
import com.example.transit.command.*
import com.example.transit.event.TransitListener
import com.example.transit.listener.GateListener
import com.example.transit.manager.*
import com.example.transit.statistics.StatisticsManager
import org.bukkit.plugin.java.JavaPlugin
import net.milkbowl.vault.economy.Economy
import org.bukkit.plugin.ServicePriority

class TransitPlugin : JavaPlugin() {
    // Using lazy initialization for managers
    val configManager by lazy { ConfigManager(this) }
    val stationManager by lazy { StationManager(this) }
    val routeManager by lazy { RouteManager(this) }
    val fareManager by lazy { FareManager(this, economy) }
    val gateManager by lazy { GateManager(this) }
    val staffManager by lazy { StaffManager(this) }
    val statisticsManager by lazy { StatisticsManager(this) }
    val transactionManager by lazy { TransactionManager(this) }
    val api by lazy { TransitAPI(this) }
    
    lateinit var economy: Economy
        private set

    override fun onEnable() {
        try {
            // Save default config and messages
            saveDefaultConfig()
            saveResource("messages.yml", false)
            reloadConfig()
            
            // Setup Vault
            if (!setupEconomy()) {
                logger.severe("Disabled due to no Vault dependency found!")
                server.pluginManager.disablePlugin(this)
                return
            }

            // Register API service
            server.servicesManager.register(
                TransitAPI::class.java,
                api,
                this,
                ServicePriority.Normal
            )

            // Register commands
            registerCommands()

            // Register events
            registerEvents()

            // Start auto-save task
            startAutoSave()

            logger.info("Transit plugin enabled successfully!")
        } catch (e: Exception) {
            logger.severe("Failed to enable Transit plugin: ${e.message}")
            e.printStackTrace()
            server.pluginManager.disablePlugin(this)
        }
    }

    private fun registerCommands() {
        getCommand("transit")?.let { cmd ->
            val executor = TransitCommand(this)
            cmd.setExecutor(executor)
            cmd.tabCompleter = executor
        }
        getCommand("station")?.let { cmd ->
            val executor = StationCommand(this)
            cmd.setExecutor(executor)
            cmd.tabCompleter = executor
        }
        getCommand("route")?.let { cmd ->
            val executor = RouteCommand(this)
            cmd.setExecutor(executor)
            cmd.tabCompleter = executor
        }
        getCommand("fare")?.let { cmd ->
            val executor = FareCommand(this)
            cmd.setExecutor(executor)
            cmd.tabCompleter = executor
        }
        getCommand("staff")?.let { cmd ->
            val executor = StaffCommand(this)
            cmd.setExecutor(executor)
            cmd.tabCompleter = executor
        }
    }

    private fun registerEvents() {
        server.pluginManager.apply {
            registerEvents(GateListener(this@TransitPlugin), this@TransitPlugin)
            registerEvents(TransitListener(this@TransitPlugin), this@TransitPlugin)
        }
    }

    private fun setupEconomy(): Boolean {
        if (server.pluginManager.getPlugin("Vault") == null) {
            return false
        }
        
        val rsp = server.servicesManager.getRegistration(Economy::class.java)
        if (rsp != null) {
            economy = rsp.provider
            return true
        }
        return false
    }

    private fun startAutoSave() {
        val saveInterval = config.getLong("settings.saveInterval", 300L) * 20L // Convert seconds to ticks
        server.scheduler.runTaskTimer(this, Runnable {
            saveAll()
        }, saveInterval, saveInterval)
    }

    fun reloadPlugin() {
        reloadConfig()
        configManager.reloadConfig()
        
        // Reload all managers
        stationManager.reload()
        routeManager.reload()
        gateManager.reload()
        staffManager.reload()
        statisticsManager.reload()
        transactionManager.reload()
        
        logger.info("Transit plugin reloaded successfully!")
    }

    private fun saveAll() {
        try {
            // Save all manager data
            stationManager.saveAll()
            routeManager.saveAll()
            gateManager.saveAll()
            staffManager.saveAll()
            statisticsManager.saveAll()
            transactionManager.saveAll()
            
            if (config.getBoolean("settings.debug", false)) {
                logger.info("Auto-save completed successfully")
            }
        } catch (e: Exception) {
            logger.severe("Failed to save plugin data: ${e.message}")
            if (config.getBoolean("settings.debug", false)) {
                e.printStackTrace()
            }
        }
    }

    override fun onDisable() {
        try {
            // Save all data before shutdown
            saveAll()
            
            // Cancel all scheduled tasks
            server.scheduler.cancelTasks(this)
            
            // Unregister API service
            server.servicesManager.unregisterAll(this)
            
            logger.info("Transit plugin disabled successfully!")
        } catch (e: Exception) {
            logger.severe("Error while disabling Transit plugin: ${e.message}")
            e.printStackTrace()
        }
    }

    companion object {
        const val PLUGIN_VERSION = "1.0.0"
        const val MINIMUM_BUKKIT_VERSION = "1.20"
        
        // Config defaults
        const val DEFAULT_SAVE_INTERVAL = 300L // 5 minutes
        const val DEFAULT_MAX_FARE = 10.0
        const val DEFAULT_BASE_FARE = 2.75
    }
}
</file>

<file path="src/main/resources/config.yml">
# Transit Plugin Configuration
settings:
  maxTapDuration: 7200  # Maximum journey time in seconds
  currency: "$"
  defaultSystem: "Subway"
  saveInterval: 300     # Auto-save interval in seconds
  debug: false

database:
  type: YAML    # YAML or MYSQL
  mysql:
    host: localhost
    port: 3306
    database: transit
    username: user
    password: pass
    prefix: transit_

systems:
  Subway:
    name: "Metro Subway"
    fareType: ZONE
    maxFare: 8.00
    zones:
      defaultFare: 5.00
      peakHours: [7, 8, 9, 16, 17, 18]  # 7-9 AM and 4-6 PM
      peakMultiplier: 1.5
      
      # Special fare rates
      specialFares:
        STUDENT: 0.5  # 50% of regular fare
        SENIOR: 0.6   # 60% of regular fare
        CHILD: 0.3    # 30% of regular fare
      
      # Zone definitions
      rings:
        "1": 0  # City center
        "2": 1  # Inner suburbs
        "3": 2  # Outer suburbs
        "4": 3  # Extended area
      
      # Zone groupings
      groups:
        city_center: ["1A", "1B", "1C"]
        inner_suburbs: ["2A", "2B", "2C"]
        outer_suburbs: ["3A", "3B", "3C"]
        airport: ["4A"]
      
      # Fare rules
      rules:
        same_zone:
          from: "\\d+"
          to: "\\1"
          fare: 2.50
        
        adjacent_zones:
          ringDifference: 1
          fare: 3.50
        
        airport_premium:
          fromGroup: "city_center"
          toGroup: "airport"
          fare: 7.50
          
        cross_zone_peak:
          ringDifference: 2
          fare: 4.50
          timeRestriction:
            startHour: 7
            endHour: 9
            daysOfWeek: [1, 2, 3, 4, 5]  # Weekdays only

  Bus:
    name: "City Bus"
    fareType: FLAT
    fare: 2.75
    maxFare: 2.75

  Rail:
    name: "Light Rail"
    fareType: DISTANCE
    baseRate: 2.00
    perBlock: 0.01
    maxFare: 5.00

staff:
  minimumBalance: 5000.0
  paymentNotifications: true
  defaultPeriod: MONTHLY

gates:
  enableAnimations: true
  soundEffects: true
  particleEffects: true
</file>

<file path="src/main/resources/plugin.yml">
name: Transit
version: ${version}
main: com.example.transit.TransitPlugin
api-version: 1.20
depend: [Vault]
commands:
  transit:
    description: Main transit command
    usage: /transit <subcommand>
  station:
    description: Station management command
    usage: /station <subcommand>
  route:
    description: Route management command
    usage: /route <subcommand>
  fare:
    description: Fare management command
    usage: /fare <subcommand>
  staff:
    description: Staff management command
    usage: /staff <subcommand>
  stats:
    description: Statistics and reporting command
    usage: /stats <subcommand>

permissions:
  transit.admin:
    description: Allows full access to all transit commands
    default: op
  transit.staff:
    description: Allows access to staff commands
    default: false
  transit.user:
    description: Allows access to user commands
    default: true
      transit.stats:
    description: Allows access to statistics commands
    default: op
  transit.stats.export:
    description: Allows exporting statistics data
    default: op
</file>

<file path="src/test/kotlin/com/example/transit/TransitPluginTest.kt">
package com.example.transit

import be.seeseemelk.mockbukkit.MockBukkit
import be.seeseemelk.mockbukkit.ServerMock
import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.*
import org.mockito.kotlin.*
import java.util.UUID

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class TransitPluginTest {
    private lateinit var server: ServerMock
    private lateinit var plugin: TransitPlugin

    @BeforeAll
    fun setUp() {
        server = MockBukkit.mock()
        plugin = MockBukkit.load(TransitPlugin::class.java)
    }

    @AfterAll
    fun tearDown() {
        MockBukkit.unmock()
    }

    @Test
    fun `test station creation`() {
        val player = server.addPlayer()
        
        // Execute station creation command
        server.executeCommand(player, "station add Subway Central_Station")
        
        // Verify station was created
        val station = plugin.stationManager.getStation("Subway_central_station")
        assertNotNull(station)
        assertEquals("Central_Station", station?.name)
        assertEquals("Subway", station?.systemId)
    }

    @Test
    fun `test fare calculation`() {
        val player = server.addPlayer()
        val startStation = createTestStation("Subway", "Start", "1")
        val endStation = createTestStation("Subway", "End", "2")
        
        val fare = plugin.fareManager.calculateFare(
            plugin.configManager.getTransitSystem("Subway")!!,
            startStation,
            endStation
        )
        
        assertTrue(fare > 0)
    }

    private fun createTestStation(systemId: String, name: String, zone: String) = 
        plugin.stationManager.addStation(
            Station(
                id = "${systemId}_${name.toLowerCase()}",
                name = name,
                systemId = systemId,
                location = server.addPlayer().location,
                zone = zone
            )
        )
}
</file>

<file path=".gitattributes">
#
# https://help.github.com/articles/dealing-with-line-endings/
#
# Linux start script should use lf
/gradlew        text eol=lf

# These are Windows script files and should use crlf
*.bat           text eol=crlf

# Binary files should be left untouched
*.jar           binary
</file>

<file path=".gitignore">
# Ignore Gradle project-specific cache directory
.gradle

# Ignore Gradle build output directory
build
</file>

<file path="build.gradle.kts">
plugins {
    kotlin("jvm") version "1.9.21"
    id("com.github.johnrengelman.shadow") version "8.1.1"
}

group = "com.example"
version = "1.0-SNAPSHOT"

// Keep Java toolchain at 21
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

// Set Kotlin to target Java 21 (latest supported)
tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        jvmTarget = "21"  // Changed from "21" to "21"
    }
}

// Keep Java compilation targeting Java 21
tasks.withType<JavaCompile> {
    sourceCompatibility = JavaVersion.VERSION_21.toString()
    targetCompatibility = JavaVersion.VERSION_21.toString()
    options.compilerArgs.add("--enable-preview")
    options.release.set(21)
}

repositories {
    mavenCentral()
    maven("https://hub.spigotmc.org/nexus/content/repositories/snapshots/")
    maven("https://jitpack.io")
}

dependencies {
    compileOnly("org.spigotmc:spigot-api:1.20.4-R0.1-SNAPSHOT")
    compileOnly("com.github.MilkBowl:VaultAPI:1.7")
    implementation(kotlin("stdlib"))
    implementation("com.zaxxer:HikariCP:5.0.1")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
    testImplementation(kotlin("test"))
    testImplementation("org.mockito:mockito-core:5.3.1")
    testImplementation("org.mockito.kotlin:mockito-kotlin:5.1.0")
}

tasks {
    shadowJar {
        archiveClassifier.set("")
        relocate("kotlin", "com.example.transit.lib.kotlin")
        minimize()
    }
    
    processResources {
        filesMatching("plugin.yml") {
            expand(
                "version" to project.version,
                "name" to project.name
            )
        }
    }

    test {
        useJUnitPlatform()
        jvmArgs("--enable-preview")
    }
}
</file>

<file path="gradle.properties">
org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError
org.gradle.parallel=true
org.gradle.caching=true
kotlin.code.style=official
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="README.md">
# Transit - Your All-in-One Minecraft Transportation Management Solution

🚇 A comprehensive Minecraft plugin for managing public transportation systems including subways, buses, and railways.

[![GitHub release](https://img.shields.io/github/v/release/yourusername/Transit)](https://github.com/yourusername/Transit/releases)
[![License](https://img.shields.io/github/license/yourusername/Transit)](LICENSE)
[![Spigot](https://img.shields.io/badge/Spigot-1.20.4-yellow.svg)](https://www.spigotmc.org/resources/transit.12345)

## Features

### 🌟 Core Features
- **Multiple Transit Systems**
  - Subway/Metro systems
  - Bus networks
  - Railway lines
  - Expandable for custom systems

- **Advanced Fare Management**
  - Zone-based fares
  - Distance-based fares
  - Flat-rate fares
  - Interchange support between systems

- **Dynamic Route System**
  - Interactive route maps
  - Interchange stations
  - Real-time journey tracking
  - Custom route creation

- **Staff Management**
  - System-specific staff roles
  - Automated salary payments
  - Staff access controls
  - Performance tracking

### 💡 Smart Features
- **Real-time Journey Tracking**
  - Journey progress display
  - Automated fare calculation
  - Time-based maximum fare charging
  - Multi-system journey support

- **Interactive Gates**
  - Smart fare gates
  - Emergency exit support
  - Staff override capabilities
  - Status monitoring

## 📋 Requirements
- Server version: 1.20+
- Dependencies:
  - Vault
  - (Optional) PlaceholderAPI
  - (Optional) WorldGuard

## 🚀 Quick Start

### Installation
1. Download the latest release
2. Place in your server's `plugins` folder
3. Restart your server
4. Configure in `plugins/Transit/config.yml`

### Basic Setup

#### 1. Create a Transit System
```
/transit create Subway "Metro System" ZONE
```

#### 2. Add Stations
```
/station add Subway Central_Station
/station add Subway Downtown
```

#### 3. Create Routes
```
/route add Subway Yellow_Line Central_Station
/route add Subway Yellow_Line Downtown
```

#### 4. Setup Fare Gates
Place a sign with:
```
[Fare]
```
Follow the chat prompts to configure the gate.

## 📖 Detailed Configuration

### Transit Systems
```yaml
systems:
  Subway:
    name: "Metro Subway"
    fareType: ZONE
    maxFare: 8.00
    zones:
      rings:
        "1": 0  # Central zone
        "2": 1  # First ring
      groups:
        city_center: ["1A", "1B"]
        suburbs: ["2A", "2B"]
```

### Fare Rules
```yaml
rules:
  same_zone:
    from: "\\d+"
    to: "\\1"
    fare: 2.50
  adjacent:
    ringDifference: 1
    fare: 3.00
```

### Staff Configuration
```yaml
staff:
  minimumBalance: 5000.0
  paymentNotifications: true
  defaultPeriod: MONTHLY
```

## 🎮 Commands

### General Commands
| Command | Description |
|---------|-------------|
| `/transit` | Main plugin command |
| `/station` | Station management |
| `/route` | Route management |
| `/fare` | Fare management |

### Admin Commands
| Command | Description |
|---------|-------------|
| `/transit staff add <system> <player>` | Add staff member |
| `/transit staff salary <system> <player> <amount>` | Set staff salary |
| `/station add <system> <name>` | Create station |
| `/route add <system> <route> <station>` | Add to route |

### User Commands
| Command | Description |
|---------|-------------|
| `/route show <route>` | View route map |
| `/station tp <name>` | Teleport to station |
| `/fare check` | Check current fare |

## 🔧 API Integration

### Maven Dependency
```xml
<dependency>
    <groupId>com.example</groupId>
    <artifactId>transit</artifactId>
    <version>1.0-SNAPSHOT</version>
    <scope>provided</scope>
</dependency>
```

### Basic Usage
```kotlin
val transitAPI = server.pluginManager.getPlugin("Transit") as? TransitPlugin

// Get station info
val station = transitAPI?.getStation("Subway", "Central_Station")

// Check staff status
val isStaff = transitAPI?.isStaffMember(player, "Subway")
```

### Event Listening
```kotlin
@EventHandler
fun onTransitGateEntry(event: TransitGateEntryEvent) {
    val player = event.player
    val station = event.station
    // Custom handling
}
```

## 🎯 Common Use Cases

### Setting Up a Metro System
1. Create the system:
   ```
   /transit create Subway "City Metro" ZONE
   ```

2. Define stations:
   ```
   /station add Subway Central
   /station add Subway North
   /station add Subway South
   ```

3. Create routes:
   ```
   /route add Subway Red_Line Central
   /route add Subway Red_Line North
   /route add Subway Red_Line South
   ```

4. Place fare gates and configure zones

### Managing Staff
1. Add staff member:
   ```
   /transit staff add Subway steve
   ```

2. Set salary:
   ```
   /transit staff salary Subway steve 1000 MONTHLY
   ```

## 📊 Statistics and Monitoring

- View system revenue:
  ```
  /transit stat Subway
  ```

- Check route usage:
  ```
  /transit stat Subway Red_Line
  ```

- Monitor station activity:
  ```
  /transit stat Subway Central
  ```

## 🔍 Troubleshooting

### Common Issues
1. **Gates not working**
   - Check station status
   - Verify sign format
   - Confirm permissions

2. **Fares not charging**
   - Check Vault connection
   - Verify fare configuration
   - Check system status

### Debug Mode
Enable debug mode in config.yml:
```yaml
settings:
  debug: true
```

## 🤝 Contributing
1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## 📜 License
This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🌟 Support
- GitHub Issues: [Report a bug](https://github.com/yourusername/Transit/issues)
- Discord: [Join our community](https://discord.gg/yourdiscord)
- Wiki: [Detailed documentation](https://github.com/yourusername/Transit/wiki)

## ✨ Acknowledgments
- Contributors
- Spigot community
- Used libraries and dependencies

---

Made by Gabriel
</file>

<file path="settings.gradle.kts">
rootProject.name = "Transit"

plugins {
    id("com.gradle.develocity") version "3.18.1"
}

// Configure Develocity
develocity {
    buildScan {
        termsOfUseUrl = "https://gradle.com/help/legal-terms-of-use"
        termsOfUseAgree = "yes"
    }
}
</file>

</repository_files>
