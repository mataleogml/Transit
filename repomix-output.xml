This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-16T16:23:38.196Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
gradle/
  wrapper/
    gradle-wrapper.properties
  libs.versions.toml
src/
  main/
    kotlin/
      com/
        example/
          transit/
            api/
              TransitAPI.kt
            command/
              FareCommand.kt
              RouteCommand.kt
              StationCommand.kt
              TransitCommand.kt
            config/
              ConfigManager.kt
              Messages.kt
            conversation/
              GateSetupConversation.kt
            event/
              TransitEvents.kt
              TransitListener.kt
            fare/
              ZoneFareCalculator.kt
            listener/
              GateListener.kt
            manager/
              ConfigManager.kt
              DatabaseManager.kt
              FareManager.kt
              GateManager.kt
              RouteManager.kt
              StaffManager.kt
              StationManager.kt
              StatisticsManager.kt
              TransactionManager.kt
            model/
              FareRule.kt
              JourneyData.kt
              Models.kt
              TransactionType.kt
            util/
              Extensions.kt
            TransitPlugin.kt
    resources/
      config.yml
      plugin.yml
  test/
    kotlin/
      com/
        example/
          transit/
            TransitPluginTest.kt
.gitattributes
.gitignore
build.gradle.kts
gradle.properties
gradlew
gradlew.bat
README.md
settings.gradle.kts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="gradle/libs.versions.toml">
# This file was generated by the Gradle 'init' task.
# https://docs.gradle.org/current/userguide/platforms.html#sub::toml-dependencies-format
</file>

<file path="src/main/kotlin/com/example/transit/api/TransitAPI.kt">
package com.example.transit.api

import com.example.transit.TransitPlugin
import com.example.transit.model.*
import org.bukkit.Location
import org.bukkit.entity.Player
import java.util.UUID

class TransitAPI(private val plugin: TransitPlugin) {
    
    fun getSystemBalance(systemId: String): Double {
        return plugin.transactionManager.getSystemBalance(systemId)
    }

    fun isStaffMember(player: Player, systemId: String): Boolean {
        return plugin.staffManager.isStaff(player.uniqueId, systemId)
    }

    fun getStation(systemId: String, stationName: String): Station? {
        return plugin.stationManager.getStation("${systemId}_${stationName.toLowerCase()}")
    }

    fun getRoute(routeId: String): Route? {
        return plugin.routeManager.getRoute(routeId)
    }

    fun getPlayerTransactions(
        playerId: UUID,
        limit: Int = 10
    ): List<Transaction> {
        return plugin.transactionManager.getTransactionsByPlayer(playerId)
            .take(limit)
    }

    fun getSystemRevenue(
        systemId: String,
        period: StatisticsManager.StatisticsPeriod = StatisticsManager.StatisticsPeriod.ALL_TIME
    ): Double {
        return plugin.statisticsManager.getSystemRevenue(systemId, period)
    }

    fun getStationStatistics(stationId: String): StatisticsManager.Statistics? {
        return plugin.statisticsManager.getStatistics("station", stationId)
    }

    fun addStation(
        systemId: String,
        name: String,
        location: Location,
        zone: String = "1"
    ): Boolean {
        val station = Station(
            id = "${systemId}_${name.toLowerCase()}",
            name = name,
            systemId = systemId,
            location = location,
            zone = zone
        )
        return try {
            plugin.stationManager.addStation(station)
            true
        } catch (e: Exception) {
            false
        }
    }

    fun addRouteStation(routeId: String, stationId: String): Boolean {
        return plugin.routeManager.addStationToRoute(routeId, stationId)
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/command/FareCommand.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import org.bukkit.entity.Player

class FareCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    override fun onCommand(sender: CommandSender, command: Command, label: String, args: Array<out String>): Boolean {
        if (args.isEmpty()) {
            sender.sendMessage("§cUsage: /fare <system/refund> [uuid]")
            return true
        }

        when (args[0].toLowerCase()) {
            "refund" -> handleRefund(sender, args)
            else -> handleSystemBalance(sender, args[0])
        }
        return true
    }

    private fun handleRefund(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /fare refund <uuid>")
            return
        }

        if (plugin.fareManager.refundTransaction(args[1])) {
            sender.sendMessage("§aTransaction refunded successfully!")
        } else {
            sender.sendMessage("§cFailed to refund transaction!")
        }
    }

    private fun handleSystemBalance(sender: CommandSender, systemId: String) {
        val balance = plugin.transactionManager.getSystemBalance(systemId)
        sender.sendMessage("§6System Balance for $systemId: §f$${balance}")
    }

    override fun onTabComplete(sender: CommandSender, command: Command, label: String, args: Array<out String>): List<String> {
        if (args.isEmpty()) return emptyList()
        
        return when (args.size) {
            1 -> listOf("refund").filter { it.startsWith(args[0].toLowerCase()) }
            else -> emptyList()
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/command/RouteCommand.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import com.example.transit.model.Route
import net.md_5.bungee.api.chat.ClickEvent
import net.md_5.bungee.api.chat.ComponentBuilder
import net.md_5.bungee.api.chat.HoverEvent
import net.md_5.bungee.api.chat.TextComponent
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import org.bukkit.entity.Player

class RouteCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    
    private val reorderingSessions = mutableMapOf<Player, ReorderSession>()

    override fun onCommand(
        sender: CommandSender,
        command: Command,
        label: String,
        args: Array<out String>
    ): Boolean {
        if (sender !is Player) {
            sender.sendMessage("§cThis command can only be used by players!")
            return true
        }

        when {
            args.isEmpty() -> {
                sendHelp(sender)
                return true
            }
            args[0].equals("add", true) -> handleAddRoute(sender, args)
            args[0].equals("show", true) -> handleShowRoute(sender, args)
            args[0].equals("addstation", true) -> handleAddStation(sender, args)
            args[0].equals("reorder", true) -> handleReorder(sender, args)
            args[0].equals("select", true) -> handleSelect(sender, args)
            else -> sendHelp(sender)
        }
        return true
    }

    private fun handleAddRoute(player: Player, args: Array<out String>) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to create routes!")
            return
        }

        if (args.size < 3) {
            player.sendMessage("§cUsage: /route add <system> <name>")
            return
        }

        val systemId = args[1]
        val name = args[2]

        val route = Route(
            id = "${systemId}_${name.toLowerCase()}",
            name = name,
            systemId = systemId
        )

        plugin.routeManager.addRoute(route)
        player.sendMessage("§aRoute $name created for system $systemId")
    }

    private fun handleAddStation(player: Player, args: Array<out String>) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to modify routes!")
            return
        }

        if (args.size < 3) {
            player.sendMessage("§cUsage: /route addstation <route> <station>")
            return
        }

        val routeId = args[1]
        val stationId = args[2]

        if (plugin.routeManager.addStationToRoute(routeId, stationId)) {
            player.sendMessage("§aStation added to route successfully!")
            handleShowRoute(player, arrayOf("show", routeId))
        } else {
            player.sendMessage("§cFailed to add station to route!")
        }
    }

    override fun onTabComplete(
        sender: CommandSender,
        command: Command,
        alias: String,
        args: Array<out String>
    ): List<String> {
        if (sender !is Player) return emptyList()
        
        return when (args.size) {
            1 -> listOf("add", "show", "addstation", "reorder")
                .filter { it.startsWith(args[0].toLowerCase()) }
            2 -> when (args[0].toLowerCase()) {
                "add" -> plugin.configManager.getSystems().map { it.id }
                "show", "reorder" -> plugin.routeManager.getSystems()
                "addstation" -> plugin.routeManager.getRoutes()
                else -> emptyList()
            }.filter { it.startsWith(args[1].toLowerCase()) }
            3 -> when (args[0].toLowerCase()) {
                "addstation" -> plugin.stationManager.getSystemStations(args[1])
                    .map { it.id }
                    .filter { it.startsWith(args[2].toLowerCase()) }
                else -> emptyList()
            }
            else -> emptyList()
        }
    }

    private fun sendHelp(player: Player) {
        player.sendMessage("""
            §6Route Commands:
            §f/route add <system> <name> - Create a new route
            §f/route show <route> - Show route details
            §f/route addstation <route> <station> - Add station to route
            §f/route reorder <route> - Reorder stations in route
        """.trimIndent())
    }

    private data class ReorderSession(
        val routeId: String,
        val selectedIndices: MutableList<Int>
    )
}
</file>

<file path="src/main/kotlin/com/example/transit/command/StationCommand.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import com.example.transit.model.Station
import com.example.transit.model.StationStatus
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import org.bukkit.entity.Player

class StationCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    
    override fun onCommand(
        sender: CommandSender,
        command: Command,
        label: String,
        args: Array<out String>
    ): Boolean {
        if (sender !is Player) {
            sender.sendMessage("§cThis command can only be used by players!")
            return true
        }

        when {
            args.isEmpty() -> {
                sendHelp(sender)
                return true
            }
            args[0].equals("add", true) -> handleAddStation(sender, args)
            args[0].equals("remove", true) -> handleRemoveStation(sender, args)
            args[0].equals("enable", true) -> handleStationStatus(sender, args, StationStatus.ACTIVE)
            args[0].equals("disable", true) -> handleStationStatus(sender, args, StationStatus.DISABLED)
            args[0].equals("tp", true) -> handleTeleport(sender, args)
            args[0].equals("list", true) -> handleList(sender, args)
            else -> sendHelp(sender)
        }
        return true
    }

    private fun handleAddStation(player: Player, args: Array<out String>) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to add stations!")
            return
        }

        if (args.size < 3) {
            player.sendMessage("§cUsage: /station add <system> <name> [zone]")
            return
        }

        val system = args[1]
        val name = args[2]
        val zone = if (args.size > 3) args[3] else "1"

        val station = Station(
            id = "${system}_${name.toLowerCase()}",
            name = name,
            systemId = system,
            location = player.location,
            zone = zone
        )

        plugin.stationManager.addStation(station)
        player.sendMessage("§aStation $name added to system $system in zone $zone")
    }

    private fun handleStationStatus(player: Player, args: Array<out String>, status: StationStatus) {
        if (!player.hasPermission("transit.admin")) {
            player.sendMessage("§cYou don't have permission to modify stations!")
            return
        }

        if (args.size < 3) {
            player.sendMessage("§cUsage: /station ${args[0]} <system> <station>")
            return
        }

        val systemId = args[1]
        val stationName = args[2]
        val stationId = "${systemId}_${stationName.toLowerCase()}"

        if (plugin.stationManager.updateStationStatus(stationId, status)) {
            val statusText = if (status == StationStatus.ACTIVE) "enabled" else "disabled"
            player.sendMessage("§aStation $stationName has been $statusText")
        } else {
            player.sendMessage("§cStation not found!")
        }
    }

    override fun onTabComplete(
        sender: CommandSender,
        command: Command,
        alias: String,
        args: Array<out String>
    ): List<String> {
        return when {
            args.isEmpty() -> listOf("add", "remove", "enable", "disable", "tp", "list")
            args.size == 1 -> listOf("add", "remove", "enable", "disable", "tp", "list")
                .filter { it.startsWith(args[0].toLowerCase()) }
            args.size == 2 -> plugin.configManager.getSystems().map { it.id }
                .filter { it.startsWith(args[1].toLowerCase()) }
            args.size == 3 -> when (args[0].toLowerCase()) {
                "tp", "enable", "disable", "remove" -> plugin.stationManager
                    .getSystemStations(args[1])
                    .map { it.name }
                    .filter { it.startsWith(args[2].toLowerCase()) }
                else -> emptyList()
            }
            else -> emptyList()
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/command/TransitCommand.kt">
package com.example.transit.command

import com.example.transit.TransitPlugin
import com.example.transit.model.FareType
import org.bukkit.command.Command
import org.bukkit.command.CommandExecutor
import org.bukkit.command.CommandSender
import org.bukkit.command.TabCompleter
import org.bukkit.entity.Player

class TransitCommand(private val plugin: TransitPlugin) : CommandExecutor, TabCompleter {
    override fun onCommand(sender: CommandSender, command: Command, label: String, args: Array<out String>): Boolean {
        if (args.isEmpty()) {
            sendHelp(sender)
            return true
        }

        when (args[0].toLowerCase()) {
            "create" -> handleCreate(sender, args)
            "staff" -> handleStaff(sender, args)
            "stat" -> handleStats(sender, args)
            else -> sendHelp(sender)
        }
        return true
    }

    private fun handleCreate(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.admin")) {
            sender.sendMessage("§cYou don't have permission to create transit systems!")
            return
        }

        if (args.size < 4) {
            sender.sendMessage("§cUsage: /transit create <id> <name> <faretype>")
            return
        }

        val id = args[1]
        val name = args[2]
        val fareType = try {
            FareType.valueOf(args[3].uppercase())
        } catch (e: IllegalArgumentException) {
            sender.sendMessage("§cInvalid fare type! Valid types: ${FareType.values().joinToString()}")
            return
        }

        // Implementation for creating transit system
        sender.sendMessage("§aTransit system created successfully!")
    }

    private fun handleStaff(sender: CommandSender, args: Array<out String>) {
        if (!sender.hasPermission("transit.admin")) {
            sender.sendMessage("§cYou don't have permission to manage staff!")
            return
        }

        if (args.size < 4) {
            sender.sendMessage("§cUsage: /transit staff <add/remove> <system> <player>")
            return
        }

        // Implementation for staff management
    }

    private fun handleStats(sender: CommandSender, args: Array<out String>) {
        if (args.size < 2) {
            sender.sendMessage("§cUsage: /transit stat <system> [period]")
            return
        }

        val systemId = args[1]
        val period = if (args.size > 2) {
            try {
                StatisticsManager.StatisticsPeriod.valueOf(args[2].uppercase())
            } catch (e: IllegalArgumentException) {
                StatisticsManager.StatisticsPeriod.ALL_TIME
            }
        } else StatisticsManager.StatisticsPeriod.ALL_TIME

        val revenue = plugin.statisticsManager.getSystemRevenue(systemId, period)
        sender.sendMessage("§6System Revenue ($period): §f$${revenue}")
    }

    private fun sendHelp(sender: CommandSender) {
        sender.sendMessage("""
            §6Transit Commands:
            §f/transit create <id> <name> <faretype> - Create a transit system
            §f/transit staff <add/remove> <system> <player> - Manage staff
            §f/transit stat <system> [period] - View statistics
        """.trimIndent())
    }

    override fun onTabComplete(sender: CommandSender, command: Command, alias: String, args: Array<out String>): List<String> {
        return when (args.size) {
            1 -> listOf("create", "staff", "stat")
                .filter { it.startsWith(args[0].toLowerCase()) }
            2 -> when (args[0].toLowerCase()) {
                "staff" -> listOf("add", "remove")
                "stat" -> plugin.configManager.getSystems().map { it.id }
                else -> emptyList()
            }.filter { it.startsWith(args[1].toLowerCase()) }
            3 -> when (args[0].toLowerCase()) {
                "create" -> FareType.values().map { it.name.toLowerCase() }
                "stat" -> StatisticsManager.StatisticsPeriod.values().map { it.name.toLowerCase() }
                else -> emptyList()
            }.filter { it.startsWith(args[2].toLowerCase()) }
            else -> emptyList()
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/config/ConfigManager.kt">
package com.example.transit.config

import com.example.transit.TransitPlugin
import com.example.transit.model.FareType
import com.example.transit.model.TransitSystem
import org.bukkit.configuration.ConfigurationSection
import java.io.File

class ConfigManager(private val plugin: TransitPlugin) {
    private val systems = mutableMapOf<String, TransitSystem>()
    private val messages = Messages(plugin)

    init {
        loadSystems()
    }

    fun getTransitSystem(id: String): TransitSystem? = systems[id]
    
    fun getSystems(): List<TransitSystem> = systems.values.toList()

    fun getMessage(key: String, vararg params: Pair<String, String>): String {
        return messages.get(key, params.toMap())
    }

    private fun loadSystems() {
        val systemsSection = plugin.config.getConfigurationSection("systems") ?: return
        
        for (systemId in systemsSection.getKeys(false)) {
            val section = systemsSection.getConfigurationSection(systemId) ?: continue
            
            try {
                systems[systemId] = TransitSystem(
                    id = systemId,
                    name = section.getString("name") ?: systemId,
                    fareType = FareType.valueOf(section.getString("fareType", "FLAT")!!.uppercase()),
                    fareData = loadFareData(section),
                    maxFare = section.getDouble("maxFare", 5.0)
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load system $systemId: ${e.message}")
            }
        }
    }

    private fun loadFareData(section: ConfigurationSection): Map<String, Any> {
        return when (FareType.valueOf(section.getString("fareType", "FLAT")!!.uppercase())) {
            FareType.ZONE -> loadZoneFareData(section)
            FareType.FLAT -> mapOf("fare" to section.getDouble("fare", 2.75))
            FareType.DISTANCE -> mapOf(
                "baseRate" to section.getDouble("baseRate", 2.0),
                "perBlock" to section.getDouble("perBlock", 0.01)
            )
        }
    }

    private fun loadZoneFareData(section: ConfigurationSection): Map<String, Any> {
        val fareData = mutableMapOf<String, Any>()
        
        section.getConfigurationSection("zones")?.let { zonesSection ->
            fareData["rings"] = loadZoneRings(zonesSection)
            fareData["groups"] = loadZoneGroups(zonesSection)
            fareData["rules"] = loadZoneRules(zonesSection)
        }
        
        return fareData
    }

    private fun loadZoneRings(section: ConfigurationSection): Map<String, Int> {
        val rings = mutableMapOf<String, Int>()
        section.getConfigurationSection("rings")?.let { ringsSection ->
            for (zone in ringsSection.getKeys(false)) {
                rings[zone] = ringsSection.getInt(zone)
            }
        }
        return rings
    }

    private fun loadZoneGroups(section: ConfigurationSection): Map<String, List<String>> {
        val groups = mutableMapOf<String, List<String>>()
        section.getConfigurationSection("groups")?.let { groupsSection ->
            for (group in groupsSection.getKeys(false)) {
                groups[group] = groupsSection.getStringList(group)
            }
        }
        return groups
    }

    private fun loadZoneRules(section: ConfigurationSection): List<Map<String, Any>> {
        val rules = mutableListOf<Map<String, Any>>()
        section.getConfigurationSection("rules")?.let { rulesSection ->
            for (rule in rulesSection.getKeys(false)) {
                val ruleSection = rulesSection.getConfigurationSection(rule) ?: continue
                rules.add(mapOf(
                    "from" to (ruleSection.getString("from") ?: ""),
                    "to" to (ruleSection.getString("to") ?: ""),
                    "fare" to ruleSection.getDouble("fare"),
                    "ringDifference" to ruleSection.getInt("ringDifference", -1),
                    "fromGroup" to (ruleSection.getString("fromGroup") ?: ""),
                    "toGroup" to (ruleSection.getString("toGroup") ?: ""),
                    "crossGroup" to ruleSection.getBoolean("crossGroup", false)
                ))
            }
        }
        return rules
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/config/Messages.kt">
package com.example.transit.config

import org.bukkit.configuration.file.YamlConfiguration
import org.bukkit.plugin.Plugin
import java.io.File

class Messages(plugin: Plugin) {
    private val messages: YamlConfiguration

    init {
        val messageFile = File(plugin.dataFolder, "messages.yml")
        if (!messageFile.exists()) {
            plugin.saveResource("messages.yml", false)
        }
        messages = YamlConfiguration.loadConfiguration(messageFile)
    }

    fun get(key: String, params: Map<String, String> = emptyMap()): String {
        var message = messages.getString(key) ?: return "§cMissing message: $key"
        params.forEach { (key, value) ->
            message = message.replace("{$key}", value)
        }
        return message.replace("&", "§")
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/conversation/GateSetupConversation.kt">
package com.example.transit.conversation

import com.example.transit.TransitPlugin
import com.example.transit.model.Gate
import org.bukkit.Location
import org.bukkit.conversations.*
import org.bukkit.entity.Player

class GateSetupConversation(
    private val plugin: TransitPlugin,
    private val location: Location,
    private val player: Player
) {
    private var lastSystem: String? = null
    private var lastStation: String? = null

    fun start() {
        val factory = ConversationFactory(plugin)
            .withModality(true)
            .withFirstPrompt(SystemPrompt())
            .withEscapeSequence("cancel")
            .withTimeout(60)
            .withLocalEcho(false)
            .addConversationAbandonedListener { event ->
                if (!event.gracefulExit()) {
                    player.sendMessage("§cGate setup cancelled!")
                }
            }

        factory.buildConversation(player).begin()
    }

    private inner class SystemPrompt : StringPrompt() {
        override fun getPromptText(context: ConversationContext): String {
            val systems = plugin.configManager.getSystems().map { it.id }
            return if (lastSystem != null) {
                "§6Enter system ID or press Enter to use last system (${lastSystem}):\n" +
                "§7Available systems: ${systems.joinToString(", ")}"
            } else {
                "§6Enter system ID:\n§7Available systems: ${systems.joinToString(", ")}"
            }
        }

        override fun acceptInput(context: ConversationContext, input: String?): Prompt? {
            val systemId = if (input.isNullOrBlank()) lastSystem else input
            
            if (systemId == null || !plugin.configManager.getTransitSystem(systemId)?.let { true } ?: false) {
                context.forWhom.sendRawMessage("§cInvalid system ID!")
                return this
            }

            context.setSessionData("system", systemId)
            lastSystem = systemId
            return StationPrompt()
        }
    }

    private inner class StationPrompt : StringPrompt() {
        override fun getPromptText(context: ConversationContext): String {
            val systemId = context.getSessionData("system") as String
            val stations = plugin.stationManager.getSystemStations(systemId).map { it.name }
            return if (lastStation != null) {
                "§6Enter station name or press Enter to use last station (${lastStation}):\n" +
                "§7Available stations: ${stations.joinToString(", ")}"
            } else {
                "§6Enter station name:\n§7Available stations: ${stations.joinToString(", ")}"
            }
        }

        override fun acceptInput(context: ConversationContext, input: String?): Prompt? {
            val systemId = context.getSessionData("system") as String
            val stationId = if (input.isNullOrBlank()) lastStation else input
            
            if (stationId == null || !plugin.stationManager.getStation("${systemId}_${stationId.toLowerCase()}")?.let { true } ?: false) {
                context.forWhom.sendRawMessage("§cInvalid station name!")
                return this
            }

            context.setSessionData("station", stationId)
            lastStation = stationId
            
            // Create the gate
            createGate(
                systemId,
                "${systemId}_${stationId.toLowerCase()}"
            )
            
            context.forWhom.sendRawMessage("§aFare gate created successfully!")
            return null
        }
    }

    private fun createGate(systemId: String, stationId: String) {
        val gate = Gate(
            id = "${systemId}_${location.blockX}_${location.blockY}_${location.blockZ}",
            location = location,
            systemId = systemId,
            stationId = stationId
        )
        plugin.gateManager.registerGate(gate)
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/event/TransitEvents.kt">
package com.example.transit.event

import com.example.transit.model.Station
import com.example.transit.model.Transaction
import org.bukkit.entity.Player
import org.bukkit.event.Event
import org.bukkit.event.HandlerList
import org.bukkit.event.Cancellable

class TransitGateEntryEvent(
    val player: Player,
    val station: Station,
    val fareAmount: Double
) : Event(), Cancellable {
    private var cancelled = false
    
    override fun isCancelled() = cancelled
    override fun setCancelled(cancel: Boolean) { cancelled = cancel }
    
    companion object {
        private val handlers = HandlerList()
        @JvmStatic
        fun getHandlerList() = handlers
    }
    override fun getHandlers() = getHandlerList()
}

class TransitGateExitEvent(
    val player: Player,
    val fromStation: Station,
    val toStation: Station,
    val fareAmount: Double,
    val transaction: Transaction
) : Event(), Cancellable {
    private var cancelled = false
    
    override fun isCancelled() = cancelled
    override fun setCancelled(cancel: Boolean) { cancelled = cancel }
    
    companion object {
        private val handlers = HandlerList()
        @JvmStatic
        fun getHandlerList() = handlers
    }
    override fun getHandlers() = getHandlerList()
}

class TransitStaffPaymentEvent(
    val player: Player,
    val systemId: String,
    val amount: Double
) : Event(), Cancellable {
    private var cancelled = false
    
    override fun isCancelled() = cancelled
    override fun setCancelled(cancel: Boolean) { cancelled = cancel }
    
    companion object {
        private val handlers = HandlerList()
        @JvmStatic
        fun getHandlerList() = handlers
    }
    override fun getHandlers() = getHandlerList()
}
</file>

<file path="src/main/kotlin/com/example/transit/event/TransitListener.kt">
package com.example.transit.event

import com.example.transit.TransitPlugin
import org.bukkit.event.EventHandler
import org.bukkit.event.EventPriority
import org.bukkit.event.Listener
import org.bukkit.event.player.PlayerJoinEvent
import org.bukkit.event.player.PlayerQuitEvent
import org.bukkit.event.server.PluginDisableEvent
import net.milkbowl.vault.economy.EconomyResponse
import org.bukkit.event.server.ServerLoadEvent

class TransitListener(private val plugin: TransitPlugin) : Listener {

    @EventHandler
    fun onPlayerJoin(event: PlayerJoinEvent) {
        // Check for pending staff payments
        if (plugin.staffManager.isStaffAnywhere(event.player.uniqueId)) {
            plugin.staffManager.checkPendingPayments(event.player)
        }

        // Check for incomplete journeys
        plugin.fareManager.checkIncompleteJourneys(event.player)
    }

    @EventHandler
    fun onPlayerQuit(event: PlayerQuitEvent) {
        // Handle any active journeys
        plugin.fareManager.handlePlayerQuit(event.player)
    }

    @EventHandler(priority = EventPriority.MONITOR)
    fun onServerLoad(event: ServerLoadEvent) {
        if (event.type == ServerLoadEvent.LoadType.RELOAD) {
            plugin.logger.warning("Plugin reloaded - Some features may not work correctly until a full restart")
        }
    }

    @EventHandler
    fun onPluginDisable(event: PluginDisableEvent) {
        if (event.plugin.name == "Vault") {
            plugin.logger.severe("Vault plugin disabled - Transit plugin may not function correctly!")
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/fare/ZoneFareCalculator.kt">
package com.example.transit.fare

import org.bukkit.configuration.ConfigurationSection

class ZoneFareCalculator(config: ConfigurationSection) {
    private val zoneRings = mutableMapOf<String, Int>()
    private val zoneGroups = mutableMapOf<String, Set<String>>()
    private val fareRules = mutableListOf<FareRule>()
    private val defaultFare: Double
    
    init {
        loadZoneConfiguration(config)
        defaultFare = config.getDouble("defaultFare", 5.0)
    }

    fun calculateFare(fromZone: String, toZone: String): Double {
        // Try exact zone match first
        fareRules.firstOrNull { it.matches(fromZone, toZone) }?.let {
            return it.fare
        }

        // Try ring-based calculation
        if (zoneRings.containsKey(fromZone) && zoneRings.containsKey(toZone)) {
            val ringDifference = Math.abs(zoneRings[fromZone]!! - zoneRings[toZone]!!)
            fareRules.firstOrNull { it.matchesRingDifference(ringDifference) }?.let {
                return it.fare
            }
        }

        return defaultFare
    }

    private fun loadZoneConfiguration(config: ConfigurationSection) {
        // Load zone rings
        config.getConfigurationSection("rings")?.let { ringsSection ->
            for (zone in ringsSection.getKeys(false)) {
                zoneRings[zone] = ringsSection.getInt(zone)
            }
        }

        // Load zone groups
        config.getConfigurationSection("groups")?.let { groupsSection ->
            for (groupName in groupsSection.getKeys(false)) {
                zoneGroups[groupName] = groupsSection.getStringList(groupName).toSet()
            }
        }

        // Load fare rules
        config.getConfigurationSection("rules")?.let { rulesSection ->
            for (ruleKey in rulesSection.getKeys(false)) {
                val ruleSection = rulesSection.getConfigurationSection(ruleKey)
                ruleSection?.let {
                    fareRules.add(FareRule(it))
                }
            }
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/listener/GateListener.kt">
package com.example.transit.listener

import com.example.transit.TransitPlugin
import org.bukkit.Material
import org.bukkit.block.Sign
import org.bukkit.event.EventHandler
import org.bukkit.event.Listener
import org.bukkit.event.block.Action
import org.bukkit.event.block.SignChangeEvent
import org.bukkit.event.player.PlayerInteractEvent

class GateListener(private val plugin: TransitPlugin) : Listener {
    
    @EventHandler
    fun onSignCreate(event: SignChangeEvent) {
        if (event.getLine(0)?.equals("[Fare]", true) != true) return
        
        if (!event.player.hasPermission("transit.admin")) {
            event.player.sendMessage("§cYou don't have permission to create fare gates!")
            event.isCancelled = true
            return
        }

        // Start gate creation conversation
        plugin.gateManager.startGateCreation(event.player, event.block.location)
    }

    @EventHandler
    fun onGateInteract(event: PlayerInteractEvent) {
        if (event.action != Action.RIGHT_CLICK_BLOCK) return
        val block = event.clickedBlock ?: return
        if (block.type != Material.OAK_WALL_SIGN && 
            block.type != Material.OAK_SIGN) return
        
        val sign = block.state as? Sign ?: return
        if (sign.getLine(0) != "§1[Fare]") return

        event.isCancelled = true
        plugin.gateManager.handleGateInteraction(event.player, sign)
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/ConfigManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.TransitSystem
import com.example.transit.model.FareType
import org.bukkit.configuration.ConfigurationSection

class ConfigManager(private val plugin: TransitPlugin) {
    private val systems = mutableMapOf<String, TransitSystem>()
    
    init {
        loadSystems()
    }

    fun getTransitSystem(id: String): TransitSystem? = systems[id]
    
    fun getSystems(): List<TransitSystem> = systems.values.toList()

    private fun loadSystems() {
        val systemsSection = plugin.config.getConfigurationSection("systems") ?: return
        
        for (systemId in systemsSection.getKeys(false)) {
            val section = systemsSection.getConfigurationSection(systemId) ?: continue
            
            try {
                systems[systemId] = TransitSystem(
                    id = systemId,
                    name = section.getString("name") ?: systemId,
                    fareType = FareType.valueOf(section.getString("fareType", "FLAT")!!.uppercase()),
                    fareData = loadFareData(section),
                    maxFare = section.getDouble("maxFare", 5.0)
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load system $systemId: ${e.message}")
            }
        }
    }

    private fun loadFareData(section: ConfigurationSection): Map<String, Any> {
        return when (FareType.valueOf(section.getString("fareType", "FLAT")!!.uppercase())) {
            FareType.ZONE -> loadZoneFareData(section)
            FareType.FLAT -> mapOf("fare" to section.getDouble("fare", 2.75))
            FareType.DISTANCE -> mapOf(
                "baseRate" to section.getDouble("baseRate", 2.0),
                "perBlock" to section.getDouble("perBlock", 0.01)
            )
        }
    }

    private fun loadZoneFareData(section: ConfigurationSection): Map<String, Any> {
        val fareData = mutableMapOf<String, Any>()
        section.getConfigurationSection("zones")?.let { zones ->
            fareData["rings"] = loadZoneRings(zones)
            fareData["groups"] = loadZoneGroups(zones)
            fareData["rules"] = loadZoneRules(zones)
        }
        return fareData
    }

    private fun loadZoneRings(section: ConfigurationSection): Map<String, Int> {
        val rings = mutableMapOf<String, Int>()
        section.getConfigurationSection("rings")?.let { ringsSection ->
            for (zone in ringsSection.getKeys(false)) {
                rings[zone] = ringsSection.getInt(zone)
            }
        }
        return rings
    }

    private fun loadZoneGroups(section: ConfigurationSection): Map<String, List<String>> {
        val groups = mutableMapOf<String, List<String>>()
        section.getConfigurationSection("groups")?.let { groupsSection ->
            for (group in groupsSection.getKeys(false)) {
                groups[group] = groupsSection.getStringList(group)
            }
        }
        return groups
    }

    private fun loadZoneRules(section: ConfigurationSection): List<Map<String, Any>> {
        val rules = mutableListOf<Map<String, Any>>()
        section.getConfigurationSection("rules")?.let { rulesSection ->
            for (rule in rulesSection.getKeys(false)) {
                val ruleSection = rulesSection.getConfigurationSection(rule) ?: continue
                rules.add(mapOf(
                    "from" to (ruleSection.getString("from") ?: ""),
                    "to" to (ruleSection.getString("to") ?: ""),
                    "fare" to ruleSection.getDouble("fare"),
                    "ringDifference" to ruleSection.getInt("ringDifference", -1),
                    "fromGroup" to (ruleSection.getString("fromGroup") ?: ""),
                    "toGroup" to (ruleSection.getString("toGroup") ?: ""),
                    "crossGroup" to ruleSection.getBoolean("crossGroup", false)
                ))
            }
        }
        return rules
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/DatabaseManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.Transaction
import com.example.transit.model.TransactionType
import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource
import java.sql.Connection
import java.sql.SQLException
import java.time.LocalDateTime
import java.util.UUID

class DatabaseManager(private val plugin: TransitPlugin) {
    private var dataSource: HikariDataSource? = null
    
    init {
        if (plugin.config.getString("database.type")?.uppercase() == "MYSQL") {
            setupHikari()
            createTables()
        }
    }

    private fun createTables() {
        executeUpdate("""
            CREATE TABLE IF NOT EXISTS ${getTableName("transactions")} (
                id VARCHAR(36) PRIMARY KEY,
                player_id VARCHAR(36) NOT NULL,
                system_id VARCHAR(50) NOT NULL,
                from_station VARCHAR(50) NOT NULL,
                to_station VARCHAR(50),
                amount DECIMAL(10,2) NOT NULL,
                type VARCHAR(20) NOT NULL,
                timestamp DATETIME NOT NULL,
                INDEX idx_player (player_id),
                INDEX idx_system (system_id),
                INDEX idx_timestamp (timestamp)
            )
        """)

        executeUpdate("""
            CREATE TABLE IF NOT EXISTS ${getTableName("statistics")} (
                id VARCHAR(36) PRIMARY KEY,
                type VARCHAR(20) NOT NULL,
                reference_id VARCHAR(50) NOT NULL,
                total_revenue DECIMAL(10,2) NOT NULL DEFAULT 0,
                total_transactions INT NOT NULL DEFAULT 0,
                last_updated DATETIME NOT NULL,
                INDEX idx_type_ref (type, reference_id)
            )
        """)
    }

    private fun setupHikari() {
        val config = HikariConfig().apply {
            jdbcUrl = buildJdbcUrl()
            username = plugin.config.getString("database.mysql.username")
            password = plugin.config.getString("database.mysql.password")
            maximumPoolSize = 10
            minimumIdle = 2
            idleTimeout = 300000
            connectionTimeout = 10000
            validationTimeout = 5000
        }

        try {
            dataSource = HikariDataSource(config)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to initialize database connection: ${e.message}")
        }
    }

    private fun buildJdbcUrl(): String {
        val host = plugin.config.getString("database.mysql.host", "localhost")
        val port = plugin.config.getInt("database.mysql.port", 3306)
        val database = plugin.config.getString("database.mysql.database", "transit")
        
        return "jdbc:mysql://$host:$port/$database?useSSL=false&serverTimezone=UTC"
    }

    fun saveTransaction(transaction: Transaction) {
        executeUpdate("""
            INSERT INTO ${getTableName("transactions")} 
            (id, player_id, system_id, from_station, to_station, amount, type, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """) { stmt ->
            stmt.setString(1, transaction.id)
            stmt.setString(2, transaction.playerId.toString())
            stmt.setString(3, transaction.systemId)
            stmt.setString(4, transaction.fromStation)
            stmt.setString(5, transaction.toStation)
            stmt.setDouble(6, transaction.amount)
            stmt.setString(7, transaction.type.name)
            stmt.setString(8, transaction.timestamp.toString())
        }
    }

    private fun getTableName(base: String): String {
        val prefix = plugin.config.getString("database.mysql.prefix", "transit_")
        return "$prefix$base"
    }

    private fun executeUpdate(sql: String, prepare: (java.sql.PreparedStatement) -> Unit = {}) {
        try {
            dataSource?.connection?.use { conn ->
                conn.prepareStatement(sql).use { stmt ->
                    prepare(stmt)
                    stmt.executeUpdate()
                }
            }
        } catch (e: SQLException) {
            plugin.logger.severe("Failed to execute update: ${e.message}")
            e.printStackTrace()
        }
    }

    fun getTransactions(
        systemId: String? = null,
        playerId: UUID? = null,
        startTime: LocalDateTime? = null,
        endTime: LocalDateTime? = null
    ): List<Transaction> {
        val conditions = mutableListOf<String>()
        val params = mutableListOf<Any>()

        systemId?.let {
            conditions.add("system_id = ?")
            params.add(it)
        }
        playerId?.let {
            conditions.add("player_id = ?")
            params.add(it.toString())
        }
        startTime?.let {
            conditions.add("timestamp >= ?")
            params.add(it.toString())
        }
        endTime?.let {
            conditions.add("timestamp <= ?")
            params.add(it.toString())
        }

        val whereClause = if (conditions.isNotEmpty()) 
            "WHERE ${conditions.joinToString(" AND ")}" else ""

        val sql = """
            SELECT * FROM ${getTableName("transactions")} 
            $whereClause 
            ORDER BY timestamp DESC
        """

        return executeQuery(sql, params) { rs ->
            Transaction(
                id = rs.getString("id"),
                playerId = UUID.fromString(rs.getString("player_id")),
                systemId = rs.getString("system_id"),
                fromStation = rs.getString("from_station"),
                toStation = rs.getString("to_station"),
                amount = rs.getDouble("amount"),
                type = TransactionType.valueOf(rs.getString("type")),
                timestamp = LocalDateTime.parse(rs.getString("timestamp"))
            )
        }
    }

    private fun <T> executeQuery(
        sql: String,
        params: List<Any> = emptyList(),
        mapper: (java.sql.ResultSet) -> T
    ): List<T> {
        val results = mutableListOf<T>()
        try {
            dataSource?.connection?.use { conn ->
                conn.prepareStatement(sql).use { stmt ->
                    params.forEachIndexed { index, param ->
                        stmt.setObject(index + 1, param)
                    }
                    val rs = stmt.executeQuery()
                    while (rs.next()) {
                        results.add(mapper(rs))
                    }
                }
            }
        } catch (e: SQLException) {
            plugin.logger.severe("Failed to execute query: ${e.message}")
            e.printStackTrace()
        }
        return results
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/FareManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.*
import net.milkbowl.vault.economy.Economy
import org.bukkit.entity.Player
import java.time.LocalDateTime
import java.util.*
import java.util.concurrent.ConcurrentHashMap

class FareManager(
    private val plugin: TransitPlugin,
    private val economy: Economy
) {
    private val activeTaps = ConcurrentHashMap<UUID, TapData>()
    private val zoneFareCalculator = ZoneFareCalculator(plugin.config.getConfigurationSection("systems"))
    
    fun handleTapIn(player: Player, systemId: String, stationId: String): Boolean {
        val station = plugin.stationManager.getStation(stationId) ?: return false
        val system = plugin.configManager.getTransitSystem(systemId) ?: return false

        when (system.fareType) {
            FareType.FLAT -> handleFlatFare(player, system, station)
            else -> {
                activeTaps[player.uniqueId] = TapData(
                    systemId = systemId,
                    stationId = stationId,
                    timestamp = LocalDateTime.now()
                )
                player.sendMessage("§aTapped in at ${station.name}")
            }
        }
        return true
    }

    fun handleTapOut(player: Player, systemId: String, stationId: String): Boolean {
        val tapData = activeTaps[player.uniqueId] ?: return false
        val system = plugin.configManager.getTransitSystem(systemId) ?: return false
        
        val fare = calculateFare(tapData, stationId, system)
        if (chargeFare(player, fare)) {
            activeTaps.remove(player.uniqueId)
            
            // Log transaction
            plugin.transactionManager.logTransaction(
                Transaction(
                    playerId = player.uniqueId,
                    systemId = systemId,
                    fromStation = tapData.stationId,
                    toStation = stationId,
                    amount = fare,
                    type = TransactionType.EXIT
                )
            )
            
            player.sendMessage("§aFare charged: $${fare}")
            return true
        }
        return false
    }

    private fun handleFlatFare(player: Player, system: TransitSystem, station: Station) {
        val fare = system.fareData["fare"] as Double
        if (chargeFare(player, fare)) {
            plugin.transactionManager.logTransaction(
                Transaction(
                    playerId = player.uniqueId,
                    systemId = system.id,
                    fromStation = station.id,
                    toStation = null,
                    amount = fare,
                    type = TransactionType.FLAT_RATE
                )
            )
            player.sendMessage("§aFare charged: $${fare}")
        }
    }

    private fun calculateFare(tapData: TapData, exitStationId: String, system: TransitSystem): Double {
        val entryStation = plugin.stationManager.getStation(tapData.stationId)!!
        val exitStation = plugin.stationManager.getStation(exitStationId)!!

        return when (system.fareType) {
            FareType.ZONE -> zoneFareCalculator.calculateFare(entryStation.zone, exitStation.zone)
            FareType.DISTANCE -> {
                val distance = entryStation.location.distance(exitStation.location)
                val baseRate = system.fareData["baseRate"] as Double
                val perBlock = system.fareData["perBlock"] as Double
                baseRate + (distance * perBlock)
            }
            FareType.FLAT -> system.fareData["fare"] as Double
        }
    }

    private fun chargeFare(player: Player, amount: Double): Boolean {
        return if (economy.has(player, amount)) {
            economy.withdrawPlayer(player, amount)
            true
        } else {
            player.sendMessage("§cInsufficient funds! Need: $$amount")
            false
        }
    }

    fun refundTransaction(transactionId: String): Boolean {
        val transaction = plugin.transactionManager.getTransaction(transactionId) ?: return false
        val player = plugin.server.getOfflinePlayer(transaction.playerId)
        
        economy.depositPlayer(player, transaction.amount)
        plugin.transactionManager.logTransaction(
            transaction.copy(
                id = UUID.randomUUID().toString(),
                type = TransactionType.REFUND,
                timestamp = LocalDateTime.now()
            )
        )
        return true
    }

    data class TapData(
        val systemId: String,
        val stationId: String,
        val timestamp: LocalDateTime
    )
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/GateManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.Gate
import com.example.transit.conversation.GateSetupConversation
import org.bukkit.Location
import org.bukkit.block.Sign
import org.bukkit.entity.Player
import org.bukkit.configuration.file.YamlConfiguration
import java.io.File

class GateManager(private val plugin: TransitPlugin) {
    private val gates = mutableMapOf<String, Gate>()
    private val gatesFile = File(plugin.dataFolder, "gates.yml")
    private val config = YamlConfiguration.loadConfiguration(gatesFile)

    init {
        loadGates()
    }

    fun startGateCreation(player: Player, location: Location) {
        GateSetupConversation(plugin, location, player).start()
    }

    fun registerGate(gate: Gate) {
        gates[gate.id] = gate
        saveGate(gate)
    }

    fun handleGateInteraction(player: Player, sign: Sign) {
        val gate = getGateAtLocation(sign.location) ?: return
        if (!gate.enabled) {
            player.sendMessage("§cThis gate is currently disabled!")
            return
        }

        // Handle fare processing through FareManager
        plugin.fareManager.handleTapIn(player, gate.systemId, gate.stationId)
    }

    private fun getGateAtLocation(location: Location): Gate? {
        val id = "${location.blockX}_${location.blockY}_${location.blockZ}"
        return gates.values.find { it.location.block == location.block }
    }

    private fun loadGates() {
        for (gateId in config.getKeys(false)) {
            val section = config.getConfigurationSection(gateId) ?: continue
            try {
                gates[gateId] = Gate(
                    id = gateId,
                    location = section.getString("location")?.toLocation() ?: continue,
                    systemId = section.getString("systemId") ?: "",
                    stationId = section.getString("stationId") ?: "",
                    enabled = section.getBoolean("enabled", true)
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load gate $gateId: ${e.message}")
            }
        }
    }

    private fun saveGate(gate: Gate) {
        config.set("${gate.id}.location", gate.location.toStorableString())
        config.set("${gate.id}.systemId", gate.systemId)
        config.set("${gate.id}.stationId", gate.stationId)
        config.set("${gate.id}.enabled", gate.enabled)
        saveConfig()
    }

    fun saveAll() {
        gates.values.forEach { saveGate(it) }
    }

    private fun saveConfig() {
        try {
            config.save(gatesFile)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save gates: ${e.message}")
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/RouteManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.Route
import org.bukkit.configuration.file.YamlConfiguration
import java.io.File

class RouteManager(private val plugin: TransitPlugin) {
    private val routes = mutableMapOf<String, Route>()
    private val routesFile: File
        get() = File(plugin.dataFolder, "routes.yml")
    private val config = YamlConfiguration.loadConfiguration(routesFile)

    init {
        loadRoutes()
    }

    fun addRoute(route: Route): Boolean {
        if (routes.containsKey(route.id)) return false
        routes[route.id] = route
        saveRoute(route)
        return true
    }

    fun getRoute(id: String): Route? = routes[id]

    fun getRoutes(): List<String> = routes.keys.toList()

    fun getSystemRoutes(systemId: String): List<Route> =
        routes.values.filter { it.systemId == systemId }

    fun getStationRoute(stationId: String): String? =
        routes.values.find { it.stations.contains(stationId) }?.id

    fun getStationRoutes(stationId: String): List<Route> =
        routes.values.filter { it.stations.contains(stationId) }

    fun addStationToRoute(routeId: String, stationId: String): Boolean {
        return routes[routeId]?.let { route ->
            if (!route.stations.contains(stationId)) {
                route.stations.add(stationId)
                saveRoute(route)
                true
            } else false
        } ?: false
    }

    fun removeStationFromRoute(routeId: String, stationId: String): Boolean {
        return routes[routeId]?.let { route ->
            if (route.stations.remove(stationId)) {
                saveRoute(route)
                true
            } else false
        } ?: false
    }

    fun reorderStations(routeId: String, newOrder: List<String>): Boolean {
        return routes[routeId]?.let { route ->
            if (route.stations.toSet() == newOrder.toSet()) {
</file>

<file path="src/main/kotlin/com/example/transit/manager/StaffManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.PaymentPeriod
import com.example.transit.model.StaffMember
import com.example.transit.model.Transaction
import com.example.transit.model.TransactionType
import org.bukkit.configuration.file.YamlConfiguration
import org.bukkit.entity.Player
import java.io.File
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit
import java.util.*
import java.util.concurrent.ConcurrentHashMap

class StaffManager(private val plugin: TransitPlugin) {
    private val staffMembers = ConcurrentHashMap<String, MutableSet<StaffMember>>()
    private val staffFile = File(plugin.dataFolder, "staff.yml")
    private val config = YamlConfiguration.loadConfiguration(staffFile)
    private val pendingPayments = ConcurrentHashMap<UUID, MutableList<Payment>>()

    init {
        loadStaffData()
        startPaymentScheduler()
    }

    fun addStaffMember(
        playerId: UUID,
        systemId: String,
        salary: Double,
        period: PaymentPeriod = PaymentPeriod.MONTHLY
    ): Boolean {
        if (isStaff(playerId, systemId)) return false

        val staffMember = StaffMember(
            playerId = playerId,
            systemId = systemId,
            salary = salary,
            paymentPeriod = period
        )
        
        staffMembers.getOrPut(systemId) { mutableSetOf() }.add(staffMember)
        saveStaffMember(staffMember)
        return true
    }

    fun removeStaffMember(playerId: UUID, systemId: String): Boolean {
        return staffMembers[systemId]?.removeIf { it.playerId == playerId } == true
    }

    fun isStaff(playerId: UUID, systemId: String): Boolean {
        return staffMembers[systemId]?.any { it.playerId == playerId } == true
    }

    fun isStaffAnywhere(playerId: UUID): Boolean {
        return staffMembers.values.any { members ->
            members.any { it.playerId == playerId }
        }
    }

    fun updateSalary(playerId: UUID, systemId: String, newSalary: Double): Boolean {
        staffMembers[systemId]?.find { it.playerId == playerId }?.let { member ->
            val updatedMember = member.copy(salary = newSalary)
            staffMembers[systemId]?.remove(member)
            staffMembers[systemId]?.add(updatedMember)
            saveStaffMember(updatedMember)
            return true
        }
        return false
    }

    private fun startPaymentScheduler() {
        plugin.server.scheduler.runTaskTimer(plugin, Runnable {
            processPayments()
        }, 72000L, 72000L) // Check every hour
    }

    private fun processPayments() {
        val now = LocalDateTime.now()
        staffMembers.forEach { (systemId, members) ->
            members.forEach { staffMember ->
                if (shouldProcessPayment(staffMember, now)) {
                    processStaffPayment(staffMember, systemId)
                }
            }
        }
    }

    private fun shouldProcessPayment(staffMember: StaffMember, now: LocalDateTime): Boolean {
        val daysSinceLastPaid = ChronoUnit.DAYS.between(staffMember.lastPaid, now)
        return when (staffMember.paymentPeriod) {
            PaymentPeriod.DAILY -> daysSinceLastPaid >= 1
            PaymentPeriod.WEEKLY -> daysSinceLastPaid >= 7
            PaymentPeriod.MONTHLY -> daysSinceLastPaid >= 30
        }
    }

    private fun processStaffPayment(staffMember: StaffMember, systemId: String) {
        val player = plugin.server.getPlayer(staffMember.playerId)
        
        if (player != null && player.isOnline) {
            payStaff(player, staffMember, systemId)
        } else {
            queuePayment(staffMember)
        }
    }

    private fun payStaff(player: Player, staffMember: StaffMember, systemId: String) {
        val systemBalance = plugin.transactionManager.getSystemBalance(systemId)
        if (systemBalance < staffMember.salary) {
            plugin.logger.warning("Insufficient system balance for staff payment: $systemId")
            return
        }

        plugin.economy.depositPlayer(player, staffMember.salary)

        plugin.transactionManager.logTransaction(
            Transaction(
                playerId = staffMember.playerId,
                systemId = systemId,
                fromStation = "STAFF_PAYMENT",
                toStation = null,
                amount = staffMember.salary,
                type = TransactionType.STAFF_PAYMENT
            )
        )

        updateLastPaidTime(staffMember)
        player.sendMessage("§aReceived staff payment: $${staffMember.salary} for system $systemId")
    }

    private fun queuePayment(staffMember: StaffMember) {
        pendingPayments.getOrPut(staffMember.playerId) { mutableListOf() }
            .add(Payment(staffMember.systemId, staffMember.salary))
    }

    fun checkPendingPayments(player: Player) {
        pendingPayments[player.uniqueId]?.let { payments ->
            payments.forEach { payment ->
                plugin.economy.depositPlayer(player, payment.amount)
                player.sendMessage("§aReceived pending staff payment: $${payment.amount}")
            }
            pendingPayments.remove(player.uniqueId)
        }
    }

    private fun updateLastPaidTime(staffMember: StaffMember) {
        staffMembers[staffMember.systemId]?.let { members ->
            members.remove(staffMember)
            members.add(staffMember.copy(lastPaid = LocalDateTime.now()))
        }
        saveStaffData()
    }

    private fun loadStaffData() {
        if (config.contains("staff")) {
            config.getConfigurationSection("staff")?.getKeys(false)?.forEach { systemId ->
                val members = mutableSetOf<StaffMember>()
                config.getConfigurationSection("staff.$systemId")?.getKeys(false)?.forEach { playerIdStr ->
                    val section = config.getConfigurationSection("staff.$systemId.$playerIdStr")
                    section?.let {
                        members.add(
                            StaffMember(
                                playerId = UUID.fromString(playerIdStr),
                                systemId = systemId,
                                salary = it.getDouble("salary"),
                                paymentPeriod = PaymentPeriod.valueOf(it.getString("period", "MONTHLY")!!),
                                lastPaid = LocalDateTime.parse(it.getString("lastPaid") 
                                    ?: LocalDateTime.now().toString())
                            )
                        )
                    }
                }
                staffMembers[systemId] = members
            }
        }
    }

    private fun saveStaffMember(staffMember: StaffMember) {
        val path = "staff.${staffMember.systemId}.${staffMember.playerId}"
        config.set("$path.salary", staffMember.salary)
        config.set("$path.period", staffMember.paymentPeriod.name)
        config.set("$path.lastPaid", staffMember.lastPaid.toString())
        saveConfig()
    }

    fun saveAll() {
        staffMembers.forEach { (systemId, members) ->
            members.forEach { staffMember ->
                saveStaffMember(staffMember)
            }
        }
    }

    private fun saveConfig() {
        try {
            config.save(staffFile)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save staff data: ${e.message}")
        }
    }

    private data class Payment(
        val systemId: String,
        val amount: Double
    )
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/StationManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.Station
import com.example.transit.model.StationStatus
import org.bukkit.configuration.file.YamlConfiguration
import java.io.File

class StationManager(private val plugin: TransitPlugin) {
    private val stations = mutableMapOf<String, Station>()
    private val stationsFile = File(plugin.dataFolder, "stations.yml")
    private val config = YamlConfiguration.loadConfiguration(stationsFile)

    init {
        loadStations()
    }

    fun addStation(station: Station): Boolean {
        if (stations.containsKey(station.id)) return false
        stations[station.id] = station
        saveStation(station)
        return true
    }

    fun getStation(id: String): Station? = stations[id]

    fun getSystemStations(systemId: String): List<Station> =
        stations.values.filter { it.systemId == systemId }

    fun updateStationStatus(stationId: String, status: StationStatus): Boolean {
        return stations[stationId]?.let { station ->
            station.status = status
            saveStation(station)
            true
        } ?: false
    }

    private fun loadStations() {
        for (stationId in config.getKeys(false)) {
            val section = config.getConfigurationSection(stationId) ?: continue
            try {
                stations[stationId] = Station(
                    id = stationId,
                    name = section.getString("name") ?: "",
                    systemId = section.getString("systemId") ?: "",
                    location = section.getString("location")?.toLocation() ?: continue,
                    zone = section.getString("zone") ?: "1",
                    status = StationStatus.valueOf(section.getString("status") ?: "ACTIVE")
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load station $stationId: ${e.message}")
            }
        }
    }

    private fun saveStation(station: Station) {
        config.set("${station.id}.name", station.name)
        config.set("${station.id}.systemId", station.systemId)
        config.set("${station.id}.location", station.location.toStorableString())
        config.set("${station.id}.zone", station.zone)
        config.set("${station.id}.status", station.status.name)
        saveConfig()
    }

    fun saveAll() {
        stations.values.forEach { saveStation(it) }
    }

    private fun saveConfig() {
        try {
            config.save(stationsFile)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save stations: ${e.message}")
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/StatisticsManager.kt">
package com.example.transit.statistics

import com.example.transit.TransitPlugin
import com.example.transit.model.Transaction
import org.bukkit.configuration.file.YamlConfiguration
import java.io.File
import java.time.LocalDateTime
import java.util.concurrent.ConcurrentHashMap

class StatisticsManager(private val plugin: TransitPlugin) {
    private val statistics = ConcurrentHashMap<String, Statistics>()
    private val statisticsFile = File(plugin.dataFolder, "statistics.yml")
    private val config = YamlConfiguration.loadConfiguration(statisticsFile)

    init {
        loadStatistics()
    }

    fun updateStatistics(transaction: Transaction) {
        // Update system statistics
        updateStats("system", transaction.systemId, transaction)

        // Update station statistics
        updateStats("station", transaction.fromStation, transaction)
        transaction.toStation?.let { updateStats("station", it, transaction) }

        // Update route statistics if available
        val fromRoute = plugin.routeManager.getStationRoute(transaction.fromStation)
        val toRoute = transaction.toStation?.let { plugin.routeManager.getStationRoute(it) }
        
        if (fromRoute != null && fromRoute == toRoute) {
            updateStats("route", fromRoute, transaction)
        }
    }

    private fun updateStats(type: String, referenceId: String, transaction: Transaction) {
        val key = "${type}_${referenceId}"
        statistics.compute(key) { _, stats ->
            (stats ?: Statistics(type, referenceId)).apply {
                totalRevenue += transaction.amount
                totalTransactions++
                lastUpdated = LocalDateTime.now()
            }
        }
        saveStatistics(key)
    }

    fun getStatistics(type: String, referenceId: String): Statistics? {
        return statistics["${type}_${referenceId}"]
    }

    fun getSystemRevenue(systemId: String, period: StatisticsPeriod = StatisticsPeriod.ALL_TIME): Double {
        return when (period) {
            StatisticsPeriod.ALL_TIME -> statistics["system_$systemId"]?.totalRevenue ?: 0.0
            StatisticsPeriod.DAILY -> calculatePeriodRevenue(systemId, 1)
            StatisticsPeriod.WEEKLY -> calculatePeriodRevenue(systemId, 7)
            StatisticsPeriod.MONTHLY -> calculatePeriodRevenue(systemId, 30)
        }
    }

    private fun calculatePeriodRevenue(systemId: String, days: Int): Double {
        val startTime = LocalDateTime.now().minusDays(days.toLong())
        return plugin.transactionManager
            .getTransactionsBySystem(systemId)
            .filter { it.timestamp.isAfter(startTime) }
            .sumOf { it.amount }
    }

    fun getStationStatistics(stationId: String): Statistics? {
        return getStatistics("station", stationId)
    }

    fun getRouteStatistics(routeId: String): Statistics? {
        return getStatistics("route", routeId)
    }

    private fun loadStatistics() {
        for (key in config.getKeys(false)) {
            val section = config.getConfigurationSection(key) ?: continue
            try {
                val type = section.getString("type") ?: continue
                val referenceId = section.getString("referenceId") ?: continue
                
                statistics[key] = Statistics(
                    type = type,
                    referenceId = referenceId,
                    totalRevenue = section.getDouble("totalRevenue"),
                    totalTransactions = section.getInt("totalTransactions"),
                    lastUpdated = LocalDateTime.parse(section.getString("lastUpdated") 
                        ?: LocalDateTime.now().toString())
                )
            } catch (e: Exception) {
                plugin.logger.severe("Failed to load statistics for $key: ${e.message}")
            }
        }
    }

    private fun saveStatistics(key: String) {
        statistics[key]?.let { stats ->
            config.set("$key.type", stats.type)
            config.set("$key.referenceId", stats.referenceId)
            config.set("$key.totalRevenue", stats.totalRevenue)
            config.set("$key.totalTransactions", stats.totalTransactions)
            config.set("$key.lastUpdated", stats.lastUpdated.toString())
        }
        saveConfig()
    }

    fun saveAll() {
        statistics.keys.forEach { saveStatistics(it) }
    }

    private fun saveConfig() {
        try {
            config.save(statisticsFile)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save statistics: ${e.message}")
        }
    }

    data class Statistics(
        val type: String,
        val referenceId: String,
        var totalRevenue: Double = 0.0,
        var totalTransactions: Int = 0,
        var lastUpdated: LocalDateTime = LocalDateTime.now()
    )

    enum class StatisticsPeriod {
        DAILY,
        WEEKLY,
        MONTHLY,
        ALL_TIME
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/manager/TransactionManager.kt">
package com.example.transit.manager

import com.example.transit.TransitPlugin
import com.example.transit.model.Transaction
import com.example.transit.model.TransactionType
import org.bukkit.configuration.file.YamlConfiguration
import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*
import java.util.concurrent.ConcurrentHashMap

class TransactionManager(private val plugin: TransitPlugin) {
    private val transactions = ConcurrentHashMap<String, Transaction>()
    private val systemBalances = ConcurrentHashMap<String, Double>()
    private val dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM")
    
    fun logTransaction(transaction: Transaction) {
        transactions[transaction.id] = transaction
        updateSystemBalance(transaction)
        saveTransaction(transaction)
        updateStatistics(transaction)
    }

    fun getTransaction(id: String): Transaction? = transactions[id]

    fun getSystemBalance(systemId: String): Double = systemBalances.getOrDefault(systemId, 0.0)

    fun getTransactionsBySystem(systemId: String): List<Transaction> =
        transactions.values.filter { it.systemId == systemId }

    fun getTransactionsByPlayer(playerId: UUID): List<Transaction> =
        transactions.values.filter { it.playerId == playerId }

    private fun updateSystemBalance(transaction: Transaction) {
        when (transaction.type) {
            TransactionType.ENTRY, TransactionType.EXIT, TransactionType.FLAT_RATE -> {
                systemBalances.merge(transaction.systemId, transaction.amount, Double::plus)
            }
            TransactionType.REFUND, TransactionType.STAFF_PAYMENT -> {
                systemBalances.merge(transaction.systemId, -transaction.amount, Double::plus)
            }
            else -> {} // Handle other transaction types
        }
    }

    private fun saveTransaction(transaction: Transaction) {
        val month = transaction.timestamp.format(dateFormatter)
        val file = getTransactionFile(month)
        val config = YamlConfiguration.loadConfiguration(file)

        config.set("${transaction.id}.playerId", transaction.playerId.toString())
        config.set("${transaction.id}.systemId", transaction.systemId)
        config.set("${transaction.id}.fromStation", transaction.fromStation)
        config.set("${transaction.id}.toStation", transaction.toStation)
        config.set("${transaction.id}.amount", transaction.amount)
        config.set("${transaction.id}.type", transaction.type.name)
        config.set("${transaction.id}.timestamp", transaction.timestamp.toString())

        try {
            config.save(file)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save transaction ${transaction.id}: ${e.message}")
        }
    }

    private fun getTransactionFile(month: String): File {
        val folder = File(plugin.dataFolder, "transactions")
        if (!folder.exists()) folder.mkdirs()
        return File(folder, "$month.yml")
    }

    private fun updateStatistics(transaction: Transaction) {
        plugin.statisticsManager.updateStatistics(transaction)
    }

    fun saveAll() {
        transactions.values.forEach { saveTransaction(it) }
        saveSystemBalances()
    }

    private fun saveSystemBalances() {
        val file = File(plugin.dataFolder, "balances.yml")
        val config = YamlConfiguration.loadConfiguration(file)

        systemBalances.forEach { (systemId, balance) ->
            config.set("balances.$systemId", balance)
        }

        try {
            config.save(file)
        } catch (e: Exception) {
            plugin.logger.severe("Failed to save system balances: ${e.message}")
        }
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/model/FareRule.kt">
package com.example.transit.model

import org.bukkit.configuration.ConfigurationSection

class FareRule(config: ConfigurationSection) {
    val fromPattern: String? = config.getString("from")
    val toPattern: String? = config.getString("to")
    val fare: Double = config.getDouble("fare")
    val ringDifference: Int? = if (config.contains("ringDifference")) config.getInt("ringDifference") else null
    val fromGroup: String? = config.getString("fromGroup")
    val toGroup: String? = config.getString("toGroup")
    val crossGroup: Boolean = config.getBoolean("crossGroup", false)

    fun matches(fromZone: String, toZone: String): Boolean {
        val fromMatches = fromPattern?.let { pattern ->
            fromZone.matches(pattern.toRegex())
        } ?: false
        
        val toMatches = toPattern?.let { pattern ->
            toZone.matches(pattern.toRegex())
        } ?: false
        
        return fromMatches && toMatches
    }

    fun matchesRingDifference(difference: Int): Boolean {
        return ringDifference != null && ringDifference == difference
    }
}
</file>

<file path="src/main/kotlin/com/example/transit/model/JourneyData.kt">
package com.example.transit.model

import org.bukkit.Location
import java.time.LocalDateTime

data class JourneyData(
    val systemId: String,
    val startStation: String,
    val startLocation: Location,
    val startTime: LocalDateTime = LocalDateTime.now()
)
</file>

<file path="src/main/kotlin/com/example/transit/model/Models.kt">
// Models.kt
package com.example.transit.model

import org.bukkit.Location
import java.time.LocalDateTime
import java.util.UUID

// Enums
enum class FareType {
    ZONE,
    FLAT,
    DISTANCE
}

enum class PaymentPeriod {
    DAILY,
    WEEKLY,
    MONTHLY
}

enum class StationStatus {
    ACTIVE,
    DISABLED,
    MAINTENANCE
}

// Data Classes
data class Station(
    val id: String,
    val name: String,
    val systemId: String,
    val location: Location,
    val zone: String,
    var status: StationStatus = StationStatus.ACTIVE
)

data class Route(
    val id: String,
    val name: String,
    val systemId: String,
    val stations: MutableList<String> = mutableListOf()
)

data class TransitSystem(
    val id: String,
    val name: String,
    val fareType: FareType,
    val fareData: Map<String, Any>,
    val maxFare: Double
)

data class Transaction(
    val id: String = UUID.randomUUID().toString(),
    val playerId: UUID,
    val systemId: String,
    val fromStation: String,
    val toStation: String?,
    val amount: Double,
    val type: TransactionType,
    val timestamp: LocalDateTime = LocalDateTime.now()
)

data class StaffMember(
    val playerId: UUID,
    val systemId: String,
    val salary: Double,
    val paymentPeriod: PaymentPeriod,
    val lastPaid: LocalDateTime = LocalDateTime.now()
)

data class Gate(
    val id: String,
    val location: Location,
    val systemId: String,
    val stationId: String,
    var enabled: Boolean = true
)

data class ZoneGroup(
    val name: String,
    val zones: Set<String>
)
</file>

<file path="src/main/kotlin/com/example/transit/model/TransactionType.kt">
package com.example.transit.model

enum class TransactionType {
    ENTRY,
    EXIT,
    INTERCHANGE_ENTRY,
    INTERCHANGE_EXIT,
    FLAT_RATE,
    REFUND,
    STAFF_PAYMENT
}
</file>

<file path="src/main/kotlin/com/example/transit/util/Extensions.kt">
package com.example.transit.util

import org.bukkit.Location
import org.bukkit.Bukkit
import org.bukkit.configuration.ConfigurationSection
import java.text.DecimalFormat
import kotlin.math.roundToInt

fun Location.toStorableString(): String {
    return "${world?.name},${x},${y},${z},${yaw},${pitch}"
}

fun String.toLocation(): Location? {
    val parts = split(",")
    if (parts.size != 6) return null
    
    return try {
        Location(
            Bukkit.getWorld(parts[0]),
            parts[1].toDouble(),
            parts[2].toDouble(),
            parts[3].toDouble(),
            parts[4].toFloat(),
            parts[5].toFloat()
        )
    } catch (e: Exception) {
        null
    }
}

fun ConfigurationSection.getLocationList(path: String): List<Location> {
    return getStringList(path).mapNotNull { it.toLocation() }
}

fun Double.roundToDecimals(decimals: Int): Double {
    val factor = 10.0.pow(decimals)
    return (this * factor).roundToInt() / factor
}

private fun Double.pow(n: Int): Double = Math.pow(this, n.toDouble())
</file>

<file path="src/main/kotlin/com/example/transit/TransitPlugin.kt">
package com.example.transit

import com.example.transit.api.TransitAPI
import com.example.transit.command.*
import com.example.transit.event.*
import com.example.transit.manager.*
import com.example.transit.statistics.StatisticsManager
import org.bukkit.plugin.java.JavaPlugin
import net.milkbowl.vault.economy.Economy

class TransitPlugin : JavaPlugin() {
    // Using lazy initialization for managers
    val configManager by lazy { ConfigManager(this) }
    val stationManager by lazy { StationManager(this) }
    val routeManager by lazy { RouteManager(this) }
    val fareManager by lazy { FareManager(this, economy) }
    val gateManager by lazy { GateManager(this) }
    val staffManager by lazy { StaffManager(this) }
    val statisticsManager by lazy { StatisticsManager(this) }
    val transactionManager by lazy { TransactionManager(this) }
    val api by lazy { TransitAPI(this) }
    
    lateinit var economy: Economy
        private set

    override fun onEnable() {
        // Save default config
        saveDefaultConfig()
        
        // Setup Vault
        if (!setupEconomy()) {
            logger.severe("Disabled due to no Vault dependency found!")
            server.pluginManager.disablePlugin(this)
            return
        }

        // Register commands
        getCommand("transit")?.setExecutor(TransitCommand(this))
        getCommand("station")?.setExecutor(StationCommand(this))
        getCommand("route")?.setExecutor(RouteCommand(this))
        getCommand("fare")?.setExecutor(FareCommand(this))

        // Register events
        server.pluginManager.apply {
            registerEvents(GateListener(this@TransitPlugin), this@TransitPlugin)
            registerEvents(TransitListener(this@TransitPlugin), this@TransitPlugin)
        }

        logger.info("Transit plugin enabled!")
    }

    private fun setupEconomy(): Boolean {
        if (server.pluginManager.getPlugin("Vault") == null) {
            return false
        }
        
        val rsp = server.servicesManager.getRegistration(Economy::class.java)
        if (rsp != null) {
            economy = rsp.provider
            return true
        }
        return false
    }

    override fun onDisable() {
        // Save all data
        stationManager.saveAll()
        routeManager.saveAll()
        staffManager.saveAll()
        statisticsManager.saveAll()
        transactionManager.saveAll()

        logger.info("Transit plugin disabled!")
    }
}
</file>

<file path="src/main/resources/config.yml">
# Transit Plugin Configuration
settings:
  maxTapDuration: 7200  # Maximum journey time in seconds
  currency: "$"
  defaultSystem: "Subway"
  saveInterval: 300     # Auto-save interval in seconds
  debug: false

database:
  type: YAML    # YAML or MYSQL
  mysql:
    host: localhost
    port: 3306
    database: transit
    username: user
    password: pass
    prefix: transit_

systems:
  Subway:
    name: "Metro Subway"
    fareType: ZONE
    maxFare: 8.00
    zones:
      rings:
        "1": 0
        "2": 1
        "3": 2
      groups:
        city_center: ["1A", "1B"]
        suburbs: ["2A", "2B"]
      rules:
        same_zone:
          from: "\\d+"
          to: "\\1"
          fare: 2.50
        adjacent:
          ringDifference: 1
          fare: 3.00
        default: 5.00

  Bus:
    name: "City Bus"
    fareType: FLAT
    fare: 2.75
    maxFare: 2.75

  Rail:
    name: "Light Rail"
    fareType: DISTANCE
    baseRate: 2.00
    perBlock: 0.01
    maxFare: 5.00

staff:
  minimumBalance: 5000.0
  paymentNotifications: true
  defaultPeriod: MONTHLY

gates:
  enableAnimations: true
  soundEffects: true
  particleEffects: true
</file>

<file path="src/main/resources/plugin.yml">
name: Transit
version: ${version}
main: com.example.transit.TransitPlugin
api-version: 1.20
depend: [Vault]
commands:
  transit:
    description: Main transit command
    usage: /transit <subcommand>
  station:
    description: Station management command
    usage: /station <subcommand>
  route:
    description: Route management command
    usage: /route <subcommand>
  fare:
    description: Fare management command
    usage: /fare <subcommand>

permissions:
  transit.admin:
    description: Allows full access to all transit commands
    default: op
  transit.staff:
    description: Allows access to staff commands
    default: false
  transit.user:
    description: Allows access to user commands
    default: true
</file>

<file path="src/test/kotlin/com/example/transit/TransitPluginTest.kt">
package com.example.transit

import be.seeseemelk.mockbukkit.MockBukkit
import be.seeseemelk.mockbukkit.ServerMock
import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.*
import org.mockito.kotlin.*
import java.util.UUID

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class TransitPluginTest {
    private lateinit var server: ServerMock
    private lateinit var plugin: TransitPlugin

    @BeforeAll
    fun setUp() {
        server = MockBukkit.mock()
        plugin = MockBukkit.load(TransitPlugin::class.java)
    }

    @AfterAll
    fun tearDown() {
        MockBukkit.unmock()
    }

    @Test
    fun `test station creation`() {
        val player = server.addPlayer()
        
        // Execute station creation command
        server.executeCommand(player, "station add Subway Central_Station")
        
        // Verify station was created
        val station = plugin.stationManager.getStation("Subway_central_station")
        assertNotNull(station)
        assertEquals("Central_Station", station?.name)
        assertEquals("Subway", station?.systemId)
    }

    @Test
    fun `test fare calculation`() {
        val player = server.addPlayer()
        val startStation = createTestStation("Subway", "Start", "1")
        val endStation = createTestStation("Subway", "End", "2")
        
        val fare = plugin.fareManager.calculateFare(
            plugin.configManager.getTransitSystem("Subway")!!,
            startStation,
            endStation
        )
        
        assertTrue(fare > 0)
    }

    private fun createTestStation(systemId: String, name: String, zone: String) = 
        plugin.stationManager.addStation(
            Station(
                id = "${systemId}_${name.toLowerCase()}",
                name = name,
                systemId = systemId,
                location = server.addPlayer().location,
                zone = zone
            )
        )
}
</file>

<file path=".gitattributes">
#
# https://help.github.com/articles/dealing-with-line-endings/
#
# Linux start script should use lf
/gradlew        text eol=lf

# These are Windows script files and should use crlf
*.bat           text eol=crlf

# Binary files should be left untouched
*.jar           binary
</file>

<file path=".gitignore">
# Ignore Gradle project-specific cache directory
.gradle

# Ignore Gradle build output directory
build
</file>

<file path="build.gradle.kts">
plugins {
    kotlin("jvm") version "1.9.21"
    id("com.github.johnrengelman.shadow") version "8.1.1"
}

group = "com.example"
version = "1.0-SNAPSHOT"

// Keep Java toolchain at 21
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

// Set Kotlin to target Java 21 (latest supported)
tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        jvmTarget = "21"  // Changed from "21" to "21"
    }
}

// Keep Java compilation targeting Java 21
tasks.withType<JavaCompile> {
    sourceCompatibility = JavaVersion.VERSION_21.toString()
    targetCompatibility = JavaVersion.VERSION_21.toString()
    options.compilerArgs.add("--enable-preview")
    options.release.set(21)
}

repositories {
    mavenCentral()
    maven("https://hub.spigotmc.org/nexus/content/repositories/snapshots/")
    maven("https://jitpack.io")
}

dependencies {
    compileOnly("org.spigotmc:spigot-api:1.20.4-R0.1-SNAPSHOT")
    compileOnly("com.github.MilkBowl:VaultAPI:1.7")
    implementation(kotlin("stdlib"))
    implementation("com.zaxxer:HikariCP:5.0.1")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
    testImplementation(kotlin("test"))
    testImplementation("org.mockito:mockito-core:5.3.1")
    testImplementation("org.mockito.kotlin:mockito-kotlin:5.1.0")
}

tasks {
    shadowJar {
        archiveClassifier.set("")
        relocate("kotlin", "com.example.transit.lib.kotlin")
        minimize()
    }
    
    processResources {
        filesMatching("plugin.yml") {
            expand(
                "version" to project.version,
                "name" to project.name
            )
        }
    }

    test {
        useJUnitPlatform()
        jvmArgs("--enable-preview")
    }
}
</file>

<file path="gradle.properties">
org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError
org.gradle.parallel=true
org.gradle.caching=true
kotlin.code.style=official
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="README.md">
# Transit - Your All-in-One Minecraft Transportation Management Solution

🚇 A comprehensive Minecraft plugin for managing public transportation systems including subways, buses, and railways.

[![GitHub release](https://img.shields.io/github/v/release/yourusername/Transit)](https://github.com/yourusername/Transit/releases)
[![License](https://img.shields.io/github/license/yourusername/Transit)](LICENSE)
[![Spigot](https://img.shields.io/badge/Spigot-1.20.4-yellow.svg)](https://www.spigotmc.org/resources/transit.12345)

## Features

### 🌟 Core Features
- **Multiple Transit Systems**
  - Subway/Metro systems
  - Bus networks
  - Railway lines
  - Expandable for custom systems

- **Advanced Fare Management**
  - Zone-based fares
  - Distance-based fares
  - Flat-rate fares
  - Interchange support between systems

- **Dynamic Route System**
  - Interactive route maps
  - Interchange stations
  - Real-time journey tracking
  - Custom route creation

- **Staff Management**
  - System-specific staff roles
  - Automated salary payments
  - Staff access controls
  - Performance tracking

### 💡 Smart Features
- **Real-time Journey Tracking**
  - Journey progress display
  - Automated fare calculation
  - Time-based maximum fare charging
  - Multi-system journey support

- **Interactive Gates**
  - Smart fare gates
  - Emergency exit support
  - Staff override capabilities
  - Status monitoring

## 📋 Requirements
- Server version: 1.20+
- Dependencies:
  - Vault
  - (Optional) PlaceholderAPI
  - (Optional) WorldGuard

## 🚀 Quick Start

### Installation
1. Download the latest release
2. Place in your server's `plugins` folder
3. Restart your server
4. Configure in `plugins/Transit/config.yml`

### Basic Setup

#### 1. Create a Transit System
```
/transit create Subway "Metro System" ZONE
```

#### 2. Add Stations
```
/station add Subway Central_Station
/station add Subway Downtown
```

#### 3. Create Routes
```
/route add Subway Yellow_Line Central_Station
/route add Subway Yellow_Line Downtown
```

#### 4. Setup Fare Gates
Place a sign with:
```
[Fare]
```
Follow the chat prompts to configure the gate.

## 📖 Detailed Configuration

### Transit Systems
```yaml
systems:
  Subway:
    name: "Metro Subway"
    fareType: ZONE
    maxFare: 8.00
    zones:
      rings:
        "1": 0  # Central zone
        "2": 1  # First ring
      groups:
        city_center: ["1A", "1B"]
        suburbs: ["2A", "2B"]
```

### Fare Rules
```yaml
rules:
  same_zone:
    from: "\\d+"
    to: "\\1"
    fare: 2.50
  adjacent:
    ringDifference: 1
    fare: 3.00
```

### Staff Configuration
```yaml
staff:
  minimumBalance: 5000.0
  paymentNotifications: true
  defaultPeriod: MONTHLY
```

## 🎮 Commands

### General Commands
| Command | Description |
|---------|-------------|
| `/transit` | Main plugin command |
| `/station` | Station management |
| `/route` | Route management |
| `/fare` | Fare management |

### Admin Commands
| Command | Description |
|---------|-------------|
| `/transit staff add <system> <player>` | Add staff member |
| `/transit staff salary <system> <player> <amount>` | Set staff salary |
| `/station add <system> <name>` | Create station |
| `/route add <system> <route> <station>` | Add to route |

### User Commands
| Command | Description |
|---------|-------------|
| `/route show <route>` | View route map |
| `/station tp <name>` | Teleport to station |
| `/fare check` | Check current fare |

## 🔧 API Integration

### Maven Dependency
```xml
<dependency>
    <groupId>com.example</groupId>
    <artifactId>transit</artifactId>
    <version>1.0-SNAPSHOT</version>
    <scope>provided</scope>
</dependency>
```

### Basic Usage
```kotlin
val transitAPI = server.pluginManager.getPlugin("Transit") as? TransitPlugin

// Get station info
val station = transitAPI?.getStation("Subway", "Central_Station")

// Check staff status
val isStaff = transitAPI?.isStaffMember(player, "Subway")
```

### Event Listening
```kotlin
@EventHandler
fun onTransitGateEntry(event: TransitGateEntryEvent) {
    val player = event.player
    val station = event.station
    // Custom handling
}
```

## 🎯 Common Use Cases

### Setting Up a Metro System
1. Create the system:
   ```
   /transit create Subway "City Metro" ZONE
   ```

2. Define stations:
   ```
   /station add Subway Central
   /station add Subway North
   /station add Subway South
   ```

3. Create routes:
   ```
   /route add Subway Red_Line Central
   /route add Subway Red_Line North
   /route add Subway Red_Line South
   ```

4. Place fare gates and configure zones

### Managing Staff
1. Add staff member:
   ```
   /transit staff add Subway steve
   ```

2. Set salary:
   ```
   /transit staff salary Subway steve 1000 MONTHLY
   ```

## 📊 Statistics and Monitoring

- View system revenue:
  ```
  /transit stat Subway
  ```

- Check route usage:
  ```
  /transit stat Subway Red_Line
  ```

- Monitor station activity:
  ```
  /transit stat Subway Central
  ```

## 🔍 Troubleshooting

### Common Issues
1. **Gates not working**
   - Check station status
   - Verify sign format
   - Confirm permissions

2. **Fares not charging**
   - Check Vault connection
   - Verify fare configuration
   - Check system status

### Debug Mode
Enable debug mode in config.yml:
```yaml
settings:
  debug: true
```

## 🤝 Contributing
1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## 📜 License
This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🌟 Support
- GitHub Issues: [Report a bug](https://github.com/yourusername/Transit/issues)
- Discord: [Join our community](https://discord.gg/yourdiscord)
- Wiki: [Detailed documentation](https://github.com/yourusername/Transit/wiki)

## ✨ Acknowledgments
- Contributors
- Spigot community
- Used libraries and dependencies

---

Made by Gabriel
</file>

<file path="settings.gradle.kts">
rootProject.name = "Transit"

plugins {
    id("com.gradle.develocity") version "3.18.1"
}

// Configure Develocity
develocity {
    buildScan {
        termsOfUseUrl = "https://gradle.com/help/legal-terms-of-use"
        termsOfUseAgree = "yes"
    }
}
</file>

</repository_files>
